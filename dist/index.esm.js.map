{"version":3,"file":"index.esm.js","sources":["../src/ioc/types.ts","../src/ioc/errors.ts","../src/ioc/injector.ts","../src/ioc/inject.ts","../src/ioc/bindings.ts","../src/ioc/provider.ts","../src/ioc/hooks.ts","../src/componentWithService.ts"],"sourcesContent":["export type Token = Function | Object | string | symbol;\r\nexport type DefinitionObject = { token: Token; binding: Function };\r\nexport type Definition = Function | [Function] | [Token, Function] | DefinitionObject;\r\n\r\nexport type Constructor<T> = new (...args: any[]) => T;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isFunction(arg: any): arg is Function {\r\n\treturn typeof arg === 'function';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isObject(arg: any): arg is Object {\r\n\treturn arg && typeof arg === 'object';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isString(arg: any): arg is string {\r\n\treturn typeof arg === 'string';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isSymbol(arg: any): arg is symbol {\r\n\treturn typeof arg === 'symbol';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isToken(arg: any): arg is Token {\r\n\treturn isFunction(arg) || isObject(arg) || isString(arg) || isSymbol(arg);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isReactComponent(prototype: any) {\r\n\treturn isObject(prototype) && isObject(prototype.isReactComponent);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isValidMetadata(arg: any): arg is Function {\r\n\treturn isFunction(arg) && [Object, Function, Number, String, Boolean].indexOf(arg) === -1;\r\n}\r\n","import { isFunction, isObject, isReactComponent, Token } from './types';\r\nimport { FunctionComponent, Component } from 'react';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getDebugName(value: FunctionComponent | Component | Object) {\r\n\tif (isFunction(value)) {\r\n\t\treturn String(value.displayName || value.name);\r\n\t}\r\n\tif (isObject(value) && isFunction(value.constructor)) {\r\n\t\treturn String(value.constructor.name);\r\n\t}\r\n\treturn String(value);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logError(message?: string) {\r\n\ttry {\r\n\t\tthrow new Error(message);\r\n\t} catch (e) {\r\n\t\tconsole.error(e);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logIncorrectBinding(token: Token, binding: Function | Object) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst bindingName = getDebugName(binding);\r\n\tlogError(`Binding [${tokenName}, ${bindingName}] is incorrect.`);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundDependency(token: Token) {\r\n\tconst name = getDebugName(token);\r\n\tlogError(\r\n\t\t`Dependency ${name} is not found.\r\nPlease register ${name} in some Provider e.g.\r\n@provider([${name}, ${name}])\r\nclass App extends React.Component { /*...*/ }`\r\n\t);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundProvider(target?: Object) {\r\n\tif (isReactComponent(target)) {\r\n\t\tconst name = getDebugName(target!);\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider and set ${name}.contextType = InjectorContext e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }\r\n  class ${name} extends React.Component {\r\n    static contextType = InjectorContext;\r\n  }`\r\n\t\t);\r\n\t} else {\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }`\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logInvalidMetadata(target: Object, token: Token) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst targetName = getDebugName(target);\r\n\tlogError(\r\n\t\t`${tokenName} is not a valid dependency.\r\nPlease specify ES6 class as property type e.g.\r\nclass MyService {}\r\nclass ${targetName} {\r\n  @inject myService: MyService;\r\n}`\r\n\t);\r\n}\r\n","import { Component, createContext } from 'react';\r\nimport { logNotFoundDependency } from './errors';\r\nimport { Token } from './types';\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__injector__') as any;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n\r\ntype InjectorContextType = { injector?: Injector };\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext<InjectorContextType>({});\r\nif (__DEV__) {\r\n\tInjectorContext.displayName = 'InjectorContext';\r\n}\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport abstract class Injector<P = {}> extends Component<P> {\r\n\t_parent?: Injector;\r\n\r\n\t_bindingMap!: Map<Token, Function>;\r\n\r\n\t_instanceMap!: Map<Token, Object>;\r\n\r\n\tabstract _initInstance(instance: Object): void;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target: Object) {\r\n\tlet injector = (target as InjectedInstance)[INJECTOR];\r\n\tif (injector) {\r\n\t\treturn injector;\r\n\t}\r\n\tinjector = currentInjector || ((target as Component).context as InjectorContextType)?.injector;\r\n\tif (injector instanceof Injector) {\r\n\t\t(target as InjectedInstance)[INJECTOR] = injector;\r\n\t\treturn injector;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nlet currentInjector: Injector | null = null;\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector: Injector | undefined, token: Token) {\r\n\tif (registrationQueue.length > 0) {\r\n\t\tregistrationQueue.forEach(registration => {\r\n\t\t\tregistration();\r\n\t\t});\r\n\t\tregistrationQueue.length = 0;\r\n\t}\r\n\twhile (injector) {\r\n\t\tlet instance = injector._instanceMap.get(token)!;\r\n\t\tif (instance !== undefined) {\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tconst binding = injector._bindingMap.get(token);\r\n\t\tif (binding) {\r\n\t\t\tconst prevInjector = currentInjector;\r\n\t\t\tcurrentInjector = injector;\r\n\t\t\ttry {\r\n\t\t\t\tinstance = binding(injector);\r\n\t\t\t} finally {\r\n\t\t\t\tcurrentInjector = prevInjector;\r\n\t\t\t}\r\n\t\t\tinjector._instanceMap.set(token, instance);\r\n\t\t\tinjector._initInstance(instance);\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tinjector = injector._parent;\r\n\t}\r\n\tif (__DEV__) {\r\n\t\tlogNotFoundDependency(token);\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const registrationQueue: (() => void)[] = [];\r\n","import 'reflect-metadata';\r\nimport { InjectorContext, getInjector, getInstance } from './injector';\r\nimport { isValidMetadata, isReactComponent, isFunction, Constructor, Token } from './types';\r\nimport { getDebugName, logInvalidMetadata, logNotFoundProvider, logError } from './errors';\r\nimport { ComponentClass } from 'react';\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param token Dependency injection token\r\n * @returns Property decorator\r\n */\r\nexport function inject(token?: Token): PropertyDecorator;\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n */\r\nexport function inject(target: Object, key: string | symbol): void;\r\n/**\r\n * Create a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param target The object in which we inject class instance\r\n * @param token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function inject<T>(target: Object, token: Constructor<T> | Token): T;\r\n\r\nexport function inject<T>(targetOrToken?: Object | Token, keyOrToken?: string | symbol | Token | Constructor<T>) {\r\n\tif (isFunction(keyOrToken)) {\r\n\t\treturn injectFunction(targetOrToken as Object, keyOrToken);\r\n\t}\r\n\r\n\tlet token = targetOrToken as Object;\r\n\tif (!keyOrToken) {\r\n\t\treturn injectDecorator;\r\n\t}\r\n\treturn injectDecorator(token, keyOrToken as string | symbol);\r\n\r\n\tfunction injectDecorator(prototype: Object, key: string | symbol) {\r\n\t\tif (__DEV__) {\r\n\t\t\tdefineContextType(prototype);\r\n\t\t} else {\r\n\t\t\t(prototype.constructor as ComponentClass).contextType = InjectorContext;\r\n\t\t}\r\n\r\n\t\tif (!token) {\r\n\t\t\ttoken = Reflect.getMetadata('design:type', prototype, key);\r\n\t\t\tif (__DEV__) {\r\n\t\t\t\tif (!isValidMetadata(token)) {\r\n\t\t\t\t\tlogInvalidMetadata(targetOrToken as Object, token);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst descriptor = {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tget() {\r\n\t\t\t\tconst instance = injectFunction(this, token);\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t\treturn instance;\r\n\t\t\t},\r\n\t\t\tset(instance: Object) {\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(prototype, key, descriptor);\r\n\r\n\t\treturn descriptor;\r\n\t}\r\n}\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Object} target The object in which we inject class instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nfunction injectFunction(target: Object, token: Token) {\r\n\tconst injector = getInjector(target);\r\n\tif (__DEV__) {\r\n\t\tif (!injector) {\r\n\t\t\tlogNotFoundProvider(target);\r\n\t\t}\r\n\t}\r\n\treturn getInstance(injector, token);\r\n}\r\n\r\n/**\r\n * Set Class.contextType = InjectorContext\r\n * @internal\r\n * @param {Object} prototype React Component prototype\r\n */\r\nfunction defineContextType(prototype: Object) {\r\n\tif (isReactComponent(prototype)) {\r\n\t\tconst constructor = prototype.constructor;\r\n\t\tconst className = getDebugName(constructor);\r\n\t\tif ((constructor as ComponentClass).contextType !== InjectorContext) {\r\n\t\t\tif ((constructor as ComponentClass).contextType) {\r\n\t\t\t\tlogError(`Decorator tries to overwrite existing ${className}.contextType`);\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(constructor, 'contextType', {\r\n\t\t\t\t\tget() {\r\n\t\t\t\t\t\treturn InjectorContext;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset() {\r\n\t\t\t\t\t\tlogError(`You are trying to overwrite ${className}.contextType = InjectorContext`);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","import { INJECTOR, getInstance, Injector } from './injector';\r\nimport { isFunction, isToken, Token, Constructor, Definition, DefinitionObject } from './types';\r\nimport { logIncorrectBinding, logError, getDebugName } from './errors';\r\n\r\nconst IS_BINDING: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__binding__') as any;\r\ninterface BindingMark {\r\n\t[IS_BINDING]?: boolean;\r\n}\r\ntype BindingFunction = ((injector: Injector) => any) & BindingMark;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n/**\r\n * Bind type to specified class.\r\n * @param constructor Service constructor\r\n * @returns Dependency resolver\r\n */\r\nexport function toClass<T>(constructor: Constructor<T>) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(constructor)) {\r\n\t\t\tlogError(`Class ${getDebugName(constructor)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => {\r\n\t\tconst instance = new constructor() as InjectedInstance;\r\n\t\tif (!instance[INJECTOR]) {\r\n\t\t\tinstance[INJECTOR] = injector;\r\n\t\t}\r\n\t\treturn instance;\r\n\t});\r\n}\r\n\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T>(factory: () => T): Function;\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param deps Factory dependencies\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T extends [any, ...any[]]>(deps: { [K in keyof T]: Constructor<T[K]> | Token }, factory: (...args: T) => any): Function;\r\nexport function toFactory(depsOrFactory?: any, factory?: any) {\r\n\tif (__DEV__) {\r\n\t\tif (factory) {\r\n\t\t\tif (!Array.isArray(depsOrFactory)) {\r\n\t\t\t\tlogError(`Dependency array ${getDebugName(depsOrFactory)} is invalid`);\r\n\t\t\t}\r\n\t\t\tif (!isFunction(factory)) {\r\n\t\t\t\tlogError(`Factory ${getDebugName(factory)} is not a valid dependency`);\r\n\t\t\t}\r\n\t\t} else if (!isFunction(depsOrFactory)) {\r\n\t\t\tlogError(`Factory ${getDebugName(depsOrFactory)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(factory ? injector => factory(...depsOrFactory.map((token: Token) => getInstance(injector, token))) : depsOrFactory);\r\n}\r\n\r\n/**\r\n * Bind type to specified value.\r\n * @param  value\r\n * @returns Dependency resolver\r\n */\r\nexport function toValue(value: any) {\r\n\tif (__DEV__) {\r\n\t\tif (value === undefined) {\r\n\t\t\tlogError(`Please specify some value`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(() => value);\r\n}\r\n\r\n/**\r\n * Bind type to existing instance located by token.\r\n * @param {Token} token\r\n * @return Dependency resolver\r\n */\r\nexport function toExisting(token: Token) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(token)) {\r\n\t\t\tlogError(`Token ${getDebugName(token)} is not a valid dependency injection token`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * Mark function as binding function.\r\n * @internal\r\n * @param {Function} binding\r\n * @returns {Function}\r\n */\r\nfunction asBinding(binding: BindingFunction): Function {\r\n\tbinding[IS_BINDING] = true;\r\n\treturn binding;\r\n}\r\n\r\n/**\r\n * Add bindings to bindings Map\r\n * @internal\r\n */\r\nexport function addBindings(bindingMap: Map<Token, Function>, definitions: Definition[]) {\r\n\tdefinitions.forEach(definition => {\r\n\t\tlet token, binding;\r\n\t\tif (typeof definition == 'object' && (definition as DefinitionObject).token && (definition as DefinitionObject).binding) {\r\n\t\t\ttoken = (definition as DefinitionObject).token;\r\n\t\t\tbinding = (definition as DefinitionObject).binding;\r\n\t\t}\r\n\t\tif (Array.isArray(definition)) {\r\n\t\t\t[token, binding = token] = definition;\r\n\t\t} else {\r\n\t\t\ttoken = binding = definition;\r\n\t\t}\r\n\t\tif (__DEV__) {\r\n\t\t\tif (!isToken(token) || !isFunction(binding)) {\r\n\t\t\t\tlogIncorrectBinding(token, binding as Object);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// @ts-ignore\r\n\t\tbindingMap.set(token, binding[IS_BINDING] ? binding : toClass(binding));\r\n\t});\r\n}\r\n","import { createElement, ComponentType, ComponentClass } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { Injector, InjectorContext, registrationQueue } from './injector';\r\nimport { addBindings } from './bindings';\r\nimport { isObject, isFunction, Definition, Token } from './types';\r\nimport { logError, getDebugName } from './errors';\r\n\r\ntype Provider = {\r\n\t/**\r\n\t * Register dependency injection bindings in scope of decorated class\r\n\t * @param definitions Dependency injection configuration\r\n\t * @returns Decorated constructor\r\n\t */\r\n\tregister(...definitions: Definition[]): void;\r\n};\r\n\r\ntype ProviderMixin<T> = T &\r\n\tProvider & {\r\n\t\tcontextType: typeof InjectorContext;\r\n\t\tWrappedComponent: T;\r\n\t};\r\n\r\nconst Initialized: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__init__') as any;\r\nexport abstract class InjectedService {\r\n\t[Initialized]?: boolean;\r\n\tabstract initProvider(refresh: () => void): void;\r\n}\r\n/**\r\n * Decorator or HOC that register dependency injection bindings\r\n * in scope of decorated class\r\n * @param definitions Dependency injection configuration\r\n * @returns Decorator or HOC\r\n */\r\nexport const provider: (...definitions: Definition[]) => <P = {}>(target: ComponentType<P>) => ProviderMixin<ComponentType<P>> = (...definitions) => Wrapped => {\r\n\tconst bindingMap = new Map<Token, Function>();\r\n\r\n\taddBindings(bindingMap, definitions);\r\n\r\n\tclass Provider extends Injector {\r\n\t\t_parent = this.context?.injector;\r\n\t\t_bindingMap = bindingMap;\r\n\t\t_instanceMap = new Map();\r\n\t\t_initInstance(instance: Object) {\r\n\t\t\tif (instance instanceof InjectedService && !instance[Initialized]) {\r\n\t\t\t\tinstance.initProvider(() => this.setState({ injector: this }));\r\n\t\t\t\tinstance[Initialized] = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcomponentDidMount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tthis._initInstance(instance);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tcomponentWillUnmount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tif (isObject(instance) && isFunction(instance.dispose)) {\r\n\t\t\t\t\tinstance.dispose();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trender() {\r\n\t\t\treturn createElement(InjectorContext.Provider, { value: { injector: this } }, createElement(Wrapped, this.props as any));\r\n\t\t}\r\n\r\n\t\tstatic WrappedComponent = Wrapped;\r\n\r\n\t\t/**\r\n\t\t * Register dependency injection bindings in scope of decorated class\r\n\t\t * @param {...Definition} definitions Dependency injection configuration\r\n\t\t */\r\n\t\tstatic register(...definitions: Definition[]) {\r\n\t\t\taddBindings(bindingMap, definitions);\r\n\t\t}\r\n\t}\r\n\r\n\tif (__DEV__) {\r\n\t\t(Provider as ComponentClass).displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n\t\tObject.defineProperty(Provider, 'contextType', {\r\n\t\t\tget() {\r\n\t\t\t\treturn InjectorContext;\r\n\t\t\t},\r\n\t\t\tset() {\r\n\t\t\t\tlogError(`You are trying to overwrite ${(Provider as ComponentClass).displayName}.contextType = InjectorContext`);\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\tProvider.contextType = InjectorContext;\r\n\t}\r\n\r\n\t// static fields from component should be visible on the generated Consumer\r\n\treturn hoistNonReactStatics(Provider, Wrapped) as any;\r\n};\r\n\r\n/**\r\n * Decorator that lazily registers class in scope of specified Provider.\r\n * @param getProvider Lambda function that returns Provider\r\n * @param biding Dependency injection binding\r\n * @returns Decorator\r\n */\r\n\r\nexport const registerIn: <T extends Function>(getProvider: () => Provider, binding?: Function) => (target: T) => T = (getProvider, binding) => constructor => {\r\n\tregistrationQueue.push(() => {\r\n\t\tif (__DEV__) {\r\n\t\t\tconst provider = getProvider();\r\n\t\t\tif (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n\t\t\t\tlogError(`${getDebugName(provider)} is not a valid Provider. Please use:\\n` + `@registerIn(() => MyProvider)\\n` + `class ${getDebugName(constructor)} {}\\n`);\r\n\t\t\t} else {\r\n\t\t\t\tprovider.register(binding ? [constructor, binding] : constructor);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tgetProvider().register(binding ? [constructor, binding] : constructor);\r\n\t\t}\r\n\t});\r\n\treturn constructor;\r\n};\r\n","import { useContext, useRef } from \"react\";\r\nimport { InjectorContext, getInstance } from \"./injector\";\r\nimport { logNotFoundProvider } from \"./errors\";\r\nimport type { Token } from './types';\r\n\r\n/**\r\n * React hook for resolving a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param  token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function useInstance(token:Token) {\r\n  const ref = useRef<Object|undefined>(undefined);\r\n  const injector = useContext(InjectorContext)?.injector;\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return ref.current || (ref.current = getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * React hook for resolving a class instances that registered by some Provider in hierarchy.\r\n * Instances are cached in Provider that registers it's classes.\r\n * @param  tokens Dependency injection tokens\r\n * @returns Resolved class instances\r\n */\r\nexport function useInstances(...tokens:Token[]) {\r\n  const ref = useRef<(Object|undefined)[] |  null>(null);\r\n  const injector = useContext(InjectorContext)?.injector;\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return (\r\n    ref.current ||\r\n    (ref.current = tokens.map(token => getInstance(injector, token)))\r\n  );\r\n}\r\n","import { createElement, FC, /* useCallback, DependencyList, */ useRef, Fragment } from 'react';\r\nimport { Definition } from './ioc/types';\r\nimport { provider } from './ioc';\r\n\r\nconst ComponentWithService: FC = ({ children }) => createElement(Fragment, null, children);\r\n\r\nexport const ComponentWithServices: FC<{\r\n\tservices: Definition[];\r\n}> = ({ services, children }) => {\r\n\tconst ref = useRef(provider(...services)(ComponentWithService));\r\n\treturn createElement(ref.current, null, children);\r\n};\r\n"],"names":[],"mappings":"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"}