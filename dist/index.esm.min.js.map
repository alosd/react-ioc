{"version":3,"file":"index.esm.min.js","sources":["../src/ioc/types.ts","../src/ioc/injector.ts","../src/ioc/inject.ts","../src/ioc/bindings.ts","../src/ioc/provider.ts","../src/ioc/hooks.ts","../src/services/service.ts","../src/services/decorators.ts","../src/componentWithService.ts"],"sourcesContent":["export type Token = Function | Object | string | symbol;\r\nexport type Definition = Function | [Function] | [Token, Function];\r\n\r\nexport type Constructor<T> = new (...args: any[]) => T;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isFunction(arg: any): arg is Function {\r\n\treturn typeof arg === 'function';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isObject(arg: any): arg is Object {\r\n\treturn arg && typeof arg === 'object';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isString(arg: any): arg is string {\r\n\treturn typeof arg === 'string';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isSymbol(arg: any): arg is symbol {\r\n\treturn typeof arg === 'symbol';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isToken(arg: any): arg is Token {\r\n\treturn isFunction(arg) || isObject(arg) || isString(arg) || isSymbol(arg);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isReactComponent(prototype: any) {\r\n\treturn isObject(prototype) && isObject(prototype.isReactComponent);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isValidMetadata(arg: any): arg is Function {\r\n\treturn isFunction(arg) && [Object, Function, Number, String, Boolean].indexOf(arg) === -1;\r\n}\r\n","import { Component, createContext } from 'react';\r\nimport { logNotFoundDependency } from './errors';\r\nimport { Token } from './types';\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__injector__') as any;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n\r\ntype InjectorContextType = { injector?: Injector };\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext<InjectorContextType>({});\r\nif (__DEV__) {\r\n\tInjectorContext.displayName = 'InjectorContext';\r\n}\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport abstract class Injector<P = {}> extends Component<P> {\r\n\t_parent?: Injector;\r\n\r\n\t_bindingMap!: Map<Token, Function>;\r\n\r\n\t_instanceMap!: Map<Token, Object>;\r\n\r\n\tabstract _initInstance(instance: Object): void;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target: Object) {\r\n\tlet injector = (target as InjectedInstance)[INJECTOR];\r\n\tif (injector) {\r\n\t\treturn injector;\r\n\t}\r\n\tinjector = currentInjector || ((target as Component).context as InjectorContextType)?.injector;\r\n\tif (injector instanceof Injector) {\r\n\t\t(target as InjectedInstance)[INJECTOR] = injector;\r\n\t\treturn injector;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nlet currentInjector: Injector | null = null;\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector: Injector | undefined, token: Token) {\r\n\tif (registrationQueue.length > 0) {\r\n\t\tregistrationQueue.forEach(registration => {\r\n\t\t\tregistration();\r\n\t\t});\r\n\t\tregistrationQueue.length = 0;\r\n\t}\r\n\twhile (injector) {\r\n\t\tlet instance = injector._instanceMap.get(token)!;\r\n\t\tif (instance !== undefined) {\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tconst binding = injector._bindingMap.get(token);\r\n\t\tif (binding) {\r\n\t\t\tconst prevInjector = currentInjector;\r\n\t\t\tcurrentInjector = injector;\r\n\t\t\ttry {\r\n\t\t\t\tinstance = binding(injector);\r\n\t\t\t} finally {\r\n\t\t\t\tcurrentInjector = prevInjector;\r\n\t\t\t}\r\n\t\t\tinjector._instanceMap.set(token, instance);\r\n\t\t\tinjector._initInstance(instance);\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tinjector = injector._parent;\r\n\t}\r\n\tif (__DEV__) {\r\n\t\tlogNotFoundDependency(token);\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const registrationQueue: (() => void)[] = [];\r\n","import 'reflect-metadata';\r\nimport { InjectorContext, getInjector, getInstance } from './injector';\r\nimport { isValidMetadata, isReactComponent, isFunction, Constructor, Token } from './types';\r\nimport { getDebugName, logInvalidMetadata, logNotFoundProvider, logError } from './errors';\r\nimport { ComponentClass } from 'react';\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param token Dependency injection token\r\n * @returns Property decorator\r\n */\r\nexport function inject(token?: Token): PropertyDecorator;\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n */\r\nexport function inject(target: Object, key: string | symbol): void;\r\n/**\r\n * Create a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param target The object in which we inject class instance\r\n * @param token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function inject<T>(target: Object, token: Constructor<T> | Token): T;\r\n\r\nexport function inject<T>(targetOrToken?: Object | Token, keyOrToken?: string | symbol | Token | Constructor<T>) {\r\n\tif (isFunction(keyOrToken)) {\r\n\t\treturn injectFunction(targetOrToken as Object, keyOrToken);\r\n\t}\r\n\r\n\tlet token = targetOrToken as Object;\r\n\tif (!keyOrToken) {\r\n\t\treturn injectDecorator;\r\n\t}\r\n\treturn injectDecorator(token, keyOrToken as string | symbol);\r\n\r\n\tfunction injectDecorator(prototype: Object, key: string | symbol) {\r\n\t\tif (__DEV__) {\r\n\t\t\tdefineContextType(prototype);\r\n\t\t} else {\r\n\t\t\t(prototype.constructor as ComponentClass).contextType = InjectorContext;\r\n\t\t}\r\n\r\n\t\tif (!token) {\r\n\t\t\ttoken = Reflect.getMetadata('design:type', prototype, key);\r\n\t\t\tif (__DEV__) {\r\n\t\t\t\tif (!isValidMetadata(token)) {\r\n\t\t\t\t\tlogInvalidMetadata(targetOrToken as Object, token);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst descriptor = {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tget() {\r\n\t\t\t\tconst instance = injectFunction(this, token);\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t\treturn instance;\r\n\t\t\t},\r\n\t\t\tset(instance: Object) {\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(prototype, key, descriptor);\r\n\r\n\t\treturn descriptor;\r\n\t}\r\n}\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Object} target The object in which we inject class instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nfunction injectFunction(target: Object, token: Token) {\r\n\tconst injector = getInjector(target);\r\n\tif (__DEV__) {\r\n\t\tif (!injector) {\r\n\t\t\tlogNotFoundProvider(target);\r\n\t\t}\r\n\t}\r\n\treturn getInstance(injector, token);\r\n}\r\n\r\n/**\r\n * Set Class.contextType = InjectorContext\r\n * @internal\r\n * @param {Object} prototype React Component prototype\r\n */\r\nfunction defineContextType(prototype: Object) {\r\n\tif (isReactComponent(prototype)) {\r\n\t\tconst constructor = prototype.constructor;\r\n\t\tconst className = getDebugName(constructor);\r\n\t\tif ((constructor as ComponentClass).contextType !== InjectorContext) {\r\n\t\t\tif ((constructor as ComponentClass).contextType) {\r\n\t\t\t\tlogError(`Decorator tries to overwrite existing ${className}.contextType`);\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(constructor, 'contextType', {\r\n\t\t\t\t\tget() {\r\n\t\t\t\t\t\treturn InjectorContext;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset() {\r\n\t\t\t\t\t\tlogError(`You are trying to overwrite ${className}.contextType = InjectorContext`);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","import { INJECTOR, getInstance, Injector } from './injector';\r\nimport { isFunction, isToken, Token, Constructor, Definition } from './types';\r\nimport { logIncorrectBinding, logError, getDebugName } from './errors';\r\n\r\nconst IS_BINDING: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__binding__') as any;\r\ninterface BindingMark {\r\n\t[IS_BINDING]?: boolean;\r\n}\r\ntype BindingFunction = ((injector: Injector) => any) & BindingMark;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n/**\r\n * Bind type to specified class.\r\n * @param constructor Service constructor\r\n * @returns Dependency resolver\r\n */\r\nexport function toClass<T>(constructor: Constructor<T>) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(constructor)) {\r\n\t\t\tlogError(`Class ${getDebugName(constructor)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => {\r\n\t\tconst instance = new constructor() as InjectedInstance;\r\n\t\tif (!instance[INJECTOR]) {\r\n\t\t\tinstance[INJECTOR] = injector;\r\n\t\t}\r\n\t\treturn instance;\r\n\t});\r\n}\r\n\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T>(factory: () => T): Function;\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param deps Factory dependencies\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T extends [any, ...any[]]>(deps: { [K in keyof T]: Constructor<T[K]> | Token }, factory: (...args: T) => any): Function;\r\nexport function toFactory(depsOrFactory?: any, factory?: any) {\r\n\tif (__DEV__) {\r\n\t\tif (factory) {\r\n\t\t\tif (!Array.isArray(depsOrFactory)) {\r\n\t\t\t\tlogError(`Dependency array ${getDebugName(depsOrFactory)} is invalid`);\r\n\t\t\t}\r\n\t\t\tif (!isFunction(factory)) {\r\n\t\t\t\tlogError(`Factory ${getDebugName(factory)} is not a valid dependency`);\r\n\t\t\t}\r\n\t\t} else if (!isFunction(depsOrFactory)) {\r\n\t\t\tlogError(`Factory ${getDebugName(depsOrFactory)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(factory ? injector => factory(...depsOrFactory.map((token: Token) => getInstance(injector, token))) : depsOrFactory);\r\n}\r\n\r\n/**\r\n * Bind type to specified value.\r\n * @param  value\r\n * @returns Dependency resolver\r\n */\r\nexport function toValue(value: any) {\r\n\tif (__DEV__) {\r\n\t\tif (value === undefined) {\r\n\t\t\tlogError(`Please specify some value`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(() => value);\r\n}\r\n\r\n/**\r\n * Bind type to existing instance located by token.\r\n * @param {Token} token\r\n * @return Dependency resolver\r\n */\r\nexport function toExisting(token: Token) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(token)) {\r\n\t\t\tlogError(`Token ${getDebugName(token)} is not a valid dependency injection token`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * Mark function as binding function.\r\n * @internal\r\n * @param {Function} binding\r\n * @returns {Function}\r\n */\r\nfunction asBinding(binding: BindingFunction): Function {\r\n\tbinding[IS_BINDING] = true;\r\n\treturn binding;\r\n}\r\n\r\n/**\r\n * Add bindings to bindings Map\r\n * @internal\r\n */\r\nexport function addBindings(bindingMap: Map<Token, Function>, definitions: Definition[]) {\r\n\tdefinitions.forEach(definition => {\r\n\t\tlet token, binding;\r\n\t\tif (Array.isArray(definition)) {\r\n\t\t\t[token, binding = token] = definition;\r\n\t\t} else {\r\n\t\t\ttoken = binding = definition;\r\n\t\t}\r\n\t\tif (__DEV__) {\r\n\t\t\tif (!isToken(token) || !isFunction(binding)) {\r\n\t\t\t\tlogIncorrectBinding(token, binding as Object);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// @ts-ignore\r\n\t\tbindingMap.set(token, binding[IS_BINDING] ? binding : toClass(binding));\r\n\t});\r\n}\r\n","import { createElement, ComponentType, ComponentClass } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { Injector, InjectorContext, registrationQueue } from './injector';\r\nimport { addBindings } from './bindings';\r\nimport { isObject, isFunction, Definition, Token } from './types';\r\nimport { logError, getDebugName } from './errors';\r\n\r\ntype Provider = {\r\n\t/**\r\n\t * Register dependency injection bindings in scope of decorated class\r\n\t * @param definitions Dependency injection configuration\r\n\t * @returns Decorated constructor\r\n\t */\r\n\tregister(...definitions: Definition[]): void;\r\n};\r\n\r\ntype ProviderMixin<T> = T &\r\n\tProvider & {\r\n\t\tcontextType: typeof InjectorContext;\r\n\t\tWrappedComponent: T;\r\n\t};\r\n\r\nconst Initialized: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__init__') as any;\r\nexport abstract class InjectedService {\r\n\t[Initialized]?: boolean;\r\n\tabstract initProvider(refresh: () => void): void;\r\n}\r\n/**\r\n * Decorator or HOC that register dependency injection bindings\r\n * in scope of decorated class\r\n * @param definitions Dependency injection configuration\r\n * @returns Decorator or HOC\r\n */\r\nexport const provider: (...definitions: Definition[]) => <P = {}>(target: ComponentType<P>) => ProviderMixin<ComponentType<P>> = (...definitions) => Wrapped => {\r\n\tconst bindingMap = new Map<Token, Function>();\r\n\r\n\taddBindings(bindingMap, definitions);\r\n\r\n\tclass Provider extends Injector {\r\n\t\t_parent = this.context?.injector;\r\n\t\t_bindingMap = bindingMap;\r\n\t\t_instanceMap = new Map();\r\n\t\t_initInstance(instance: Object) {\r\n\t\t\tif (instance instanceof InjectedService && !instance[Initialized]) {\r\n\t\t\t\tinstance.initProvider(() => this.setState({ injector: this }));\r\n\t\t\t\tinstance[Initialized] = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcomponentDidMount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tthis._initInstance(instance);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tcomponentWillUnmount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tif (isObject(instance) && isFunction(instance.dispose)) {\r\n\t\t\t\t\tinstance.dispose();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trender() {\r\n\t\t\treturn createElement(InjectorContext.Provider, { value: { injector: this } }, createElement(Wrapped, this.props as any));\r\n\t\t}\r\n\r\n\t\tstatic WrappedComponent = Wrapped;\r\n\r\n\t\t/**\r\n\t\t * Register dependency injection bindings in scope of decorated class\r\n\t\t * @param {...Definition} definitions Dependency injection configuration\r\n\t\t */\r\n\t\tstatic register(...definitions: Definition[]) {\r\n\t\t\taddBindings(bindingMap, definitions);\r\n\t\t}\r\n\t}\r\n\r\n\tif (__DEV__) {\r\n\t\t(Provider as ComponentClass).displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n\t\tObject.defineProperty(Provider, 'contextType', {\r\n\t\t\tget() {\r\n\t\t\t\treturn InjectorContext;\r\n\t\t\t},\r\n\t\t\tset() {\r\n\t\t\t\tlogError(`You are trying to overwrite ${(Provider as ComponentClass).displayName}.contextType = InjectorContext`);\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\tProvider.contextType = InjectorContext;\r\n\t}\r\n\r\n\t// static fields from component should be visible on the generated Consumer\r\n\treturn hoistNonReactStatics(Provider, Wrapped) as any;\r\n};\r\n\r\n/**\r\n * Decorator that lazily registers class in scope of specified Provider.\r\n * @param getProvider Lambda function that returns Provider\r\n * @param biding Dependency injection binding\r\n * @returns Decorator\r\n */\r\n\r\nexport const registerIn: <T extends Function>(getProvider: () => Provider, binding?: Function) => (target: T) => T = (getProvider, binding) => constructor => {\r\n\tregistrationQueue.push(() => {\r\n\t\tif (__DEV__) {\r\n\t\t\tconst provider = getProvider();\r\n\t\t\tif (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n\t\t\t\tlogError(`${getDebugName(provider)} is not a valid Provider. Please use:\\n` + `@registerIn(() => MyProvider)\\n` + `class ${getDebugName(constructor)} {}\\n`);\r\n\t\t\t} else {\r\n\t\t\t\tprovider.register(binding ? [constructor, binding] : constructor);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tgetProvider().register(binding ? [constructor, binding] : constructor);\r\n\t\t}\r\n\t});\r\n\treturn constructor;\r\n};\r\n","import { useContext, useRef } from \"react\";\r\nimport { InjectorContext, getInstance } from \"./injector\";\r\nimport { logNotFoundProvider } from \"./errors\";\r\nimport type { Token } from './types';\r\n\r\n/**\r\n * React hook for resolving a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param  token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function useInstance(token:Token) {\r\n  const ref = useRef<Object|undefined>(undefined);\r\n  const injector = useContext(InjectorContext)?.injector;\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return ref.current || (ref.current = getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * React hook for resolving a class instances that registered by some Provider in hierarchy.\r\n * Instances are cached in Provider that registers it's classes.\r\n * @param  tokens Dependency injection tokens\r\n * @returns Resolved class instances\r\n */\r\nexport function useInstances(...tokens:Token[]) {\r\n  const ref = useRef<(Object|undefined)[] |  null>(null);\r\n  const injector = useContext(InjectorContext)?.injector;\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return (\r\n    ref.current ||\r\n    (ref.current = tokens.map(token => getInstance(injector, token)))\r\n  );\r\n}\r\n","import { Draft, createDraft, finishDraft, immerable } from 'immer';\r\nimport { logError } from '../ioc/errors';\r\nimport { InjectedService } from '../ioc/provider';\r\n\r\nexport const PROVIDER: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__store__') as any;\r\nexport const STORES: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__stores__') as any;\r\nexport const REFRESH: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__refresh__') as any;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ImmutableServiceInternal {\r\n\t[REFRESH]?: () => void;\r\n\t[PROVIDER]: MutationProvider;\r\n\t[STORES]: string[];\r\n\t[index: string]: any;\r\n\tRefreshContext(): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n\r\nclass MutationProvider {\r\n\tprivate count = 0;\r\n\tprivate draft?: Draft<ImmutableServiceInternal>;\r\n\tprivate service: ImmutableServiceInternal;\r\n\tconstructor(service: ImmutableService) {\r\n\t\tthis.service = (service as unknown) as ImmutableServiceInternal;\r\n\t}\r\n\tstart(inc = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconst draft = (this.draft = this.draft ?? createDraft(this.service));\r\n\r\n\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\tthis.service[x] = draft[x];\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (inc) this.count++;\r\n\t}\r\n\tfinish(refresh: boolean = true, dec = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconsole.warn('the finish method must be called after corresponding start method');\r\n\t\t} else {\r\n\t\t\tif (dec) this.count--;\r\n\t\t\tif (this.count == 0) {\r\n\t\t\t\tconst draft = this.draft;\r\n\t\t\t\tif (draft) {\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tdraft[x] = this.service[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tconst newstate = finishDraft(draft);\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tthis.service[x] = newstate[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.draft = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (__DEV__) {\r\n\t\t\t\t\t\tlogError('previous state is absent');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (refresh) {\r\n\t\t\tthis.service.RefreshContext();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// @ts-ignore\r\nexport abstract class ImmutableService extends InjectedService {\r\n\tprivate [REFRESH]: () => void;\r\n\t// @ts-ignore\r\n\tprivate [STORES]: string[];\r\n\t// @ts-ignore\r\n\tprivate [PROVIDER]: MutationProvider;\r\n\t// @ts-ignore\r\n\tprivate [immerable]: boolean;\r\n\r\n\t// @ts-ignore\r\n\tprivate initProvider(refresh: () => void) {\r\n\t\tthis[REFRESH] = refresh;\r\n\t\tthis[PROVIDER].start();\r\n\t\tthis[PROVIDER].finish();\r\n\t}\r\n\r\n\tprotected RefreshContext() {\r\n\t\tif (this[REFRESH]) {\r\n\t\t\tthis[REFRESH]();\r\n\t\t}\r\n\t}\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis[STORES] = this[STORES] ?? [];\r\n\t\tthis[immerable] = true;\r\n\t\tthis[PROVIDER] = new MutationProvider(this);\r\n\t}\r\n\r\n\tprotected async waitForAsync<T>(promise: Promise<T>) {\r\n\t\tthis[PROVIDER].finish(true, false);\r\n\t\ttry {\r\n\t\t\treturn await promise;\r\n\t\t} finally {\r\n\t\t\tthis[PROVIDER].start(false);\r\n\t\t}\r\n\t}\r\n}\r\n","import { ImmutableServiceInternal, ImmutableService, STORES, PROVIDER } from './service';\r\n\r\n/**\r\n * Property Decorator convert property to immutable\r\n * Changes for such property allowed only from methods marked with @action or @asyncAction decorator\r\n */\r\nexport function store() {\r\n\treturn function(target: ImmutableService, propertyKey: string) {\r\n\t\tconst service = (target as unknown) as ImmutableServiceInternal;\r\n\t\tservice[STORES] = service[STORES] ?? [];\r\n\t\tservice[STORES].push(propertyKey);\r\n\t};\r\n}\r\n\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\n// export function asyncAction() {\r\n// \treturn function(target: ImmutableService, propertyKey: string, descriptor: PropertyDescriptor) {\r\n// \t\tconst fn = descriptor.value as Function;\r\n// \t\tdescriptor.value = async function(args: any[]) {\r\n// \t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n// \t\t\tlet res = undefined;\r\n// \t\t\ttry {\r\n// \t\t\t\tres = await fn.call(this, args);\r\n// \t\t\t} finally {\r\n// \t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n// \t\t\t}\r\n\r\n// \t\t\treturn res;\r\n// \t\t};\r\n// \t};\r\n// }\r\n\r\nconst waitForFinish = async (service: ImmutableServiceInternal, promise: Promise<any>) => {\r\n\ttry {\r\n\t\treturn await promise;\r\n\t} finally {\r\n\t\tservice[PROVIDER].finish();\r\n\t}\r\n};\r\nconst checkForPromise = (value: any) => {\r\n\t//return value instanceof Promise\r\n\treturn value && typeof value['then'] === 'function';\r\n};\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\nexport function action() {\r\n\treturn function(_target: ImmutableService, _propertyKey: string, descriptor: PropertyDescriptor) {\r\n\t\tconst fn = descriptor.value as Function;\r\n\t\tdescriptor.value = function(args: any[]) {\r\n\t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n\r\n\t\t\tlet isPromise = false;\r\n\t\t\ttry {\r\n\t\t\t\tlet res = fn.call(this, args);\r\n\t\t\t\tisPromise = checkForPromise(res);\r\n\t\t\t\tif (isPromise) {\r\n\t\t\t\t\treturn waitForFinish(this as ImmutableServiceInternal, res);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn res;\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (!isPromise) {\r\n\t\t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n}\r\n","import { createElement, FC, useCallback, DependencyList } from 'react';\r\nimport { Definition } from './ioc/types';\r\nimport { provider } from './ioc';\r\n\r\nexport const ComponentWithServices: FC<{\r\n\tservices: Definition[];\r\n\tdeps?: DependencyList;\r\n}> = ({ services, children, deps }) => {\r\n\tconst ComponentWithService = useCallback(\r\n\t\t(() => {\r\n\t\t\tconst fn = () => children;\r\n\t\t\tif (__DEV__) {\r\n\t\t\t\tfn.displayName = 'ComponentWithServices.Children';\r\n\t\t\t}\r\n\t\t\treturn provider(...services)(fn as FC) as FC;\r\n\t\t})(),\r\n\t\tdeps ?? []\r\n\t);\r\n\treturn createElement(ComponentWithService);\r\n};\r\n"],"names":["isFunction","arg","isObject","INJECTOR","Symbol","InjectorContext","createContext","__extends","Component","getInjector","target","injector","currentInjector","context","Injector","getInstance","token","registrationQueue","length","forEach","registration","instance","_instanceMap","get","undefined","binding","_bindingMap","prevInjector","set","_initInstance","_parent","inject","targetOrToken","keyOrToken","injectFunction","injectDecorator","prototype","key","constructor","contextType","Reflect","getMetadata","descriptor","configurable","enumerable","this","Object","defineProperty","writable","value","IS_BINDING","toClass","asBinding","toFactory","depsOrFactory","factory","map","toValue","toExisting","addBindings","bindingMap","definitions","definition","Array","isArray","_a","Initialized","provider","_i","Wrapped","Map","_this","Provider","InjectedService","initProvider","setState","dispose","createElement","props","hoistNonReactStatics","registerIn","getProvider","push","register","useInstance","ref","useRef","useContext","current","useInstances","tokens","PROVIDER","STORES","REFRESH","service","MutationProvider","inc","count","draft_1","draft","createDraft","x","refresh","dec","console","warn","draft_2","newstate_1","finishDraft","RefreshContext","_super","immerable","ImmutableService","start","finish","promise","store","propertyKey","waitForFinish","checkForPromise","action","_target","_propertyKey","fn","args","isPromise","res","call","ComponentWithServices","services","children","deps","ComponentWithService","useCallback"],"mappings":"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"}