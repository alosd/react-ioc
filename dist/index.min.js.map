{"version":3,"file":"index.min.js","sources":["../src/liteEvent.ts","../src/ioc/types.ts","../src/ioc/injector.ts","../src/ioc/inject.ts","../src/ioc/bindings.ts","../src/ioc/provider.ts","../src/ioc/hooks.ts","../src/componentWithService.ts"],"sourcesContent":["/* Lite Event exports */\r\ntype ActionsType<T> = (data?: T) => void;\r\n\r\nexport interface LiteEvent<T = void> {\r\n\ton(handler: ActionsType<T>): ActionsType<T>;\r\n\toff(handler: ActionsType<T>): void;\r\n}\r\n\r\nexport class LiteEventImpl<T = void> implements LiteEvent<T> {\r\n\tprivate handlers: ActionsType<T>[] = [];\r\n\r\n\t// on(handler: () => void): () => void;\r\n\r\n\ton(handler: ActionsType<T>) {\r\n\t\tthis.handlers.push(handler);\r\n\t\treturn handler;\r\n\t}\r\n\r\n\toff(handler: ActionsType<T>) {\r\n\t\tthis.handlers = this.handlers.filter(h => h !== handler);\r\n\t}\r\n\r\n\ttrigger(data: T) {\r\n\t\tthis.handlers.slice(0).forEach(h => h(data!));\r\n\t}\r\n}\r\n","export type Token = Function | Object | string | symbol;\r\nexport type DefinitionObject = { token: Token; binding: Function };\r\nexport type Definition = Function | [Function] | [Token, Function] | DefinitionObject;\r\n\r\nexport type Constructor<T> = new (...args: any[]) => T;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isFunction(arg: any): arg is Function {\r\n\treturn typeof arg === 'function';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isObject(arg: any): arg is Object {\r\n\treturn arg && typeof arg === 'object';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isString(arg: any): arg is string {\r\n\treturn typeof arg === 'string';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isSymbol(arg: any): arg is symbol {\r\n\treturn typeof arg === 'symbol';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isToken(arg: any): arg is Token {\r\n\treturn isFunction(arg) || isObject(arg) || isString(arg) || isSymbol(arg);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isReactComponent(prototype: any) {\r\n\treturn isObject(prototype) && isObject(prototype.isReactComponent);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isValidMetadata(arg: any): arg is Function {\r\n\treturn isFunction(arg) && [Object, Function, Number, String, Boolean].indexOf(arg) === -1;\r\n}\r\n","import { Component, createContext } from 'react';\r\nimport { LiteEventImpl } from '../liteEvent';\r\nimport { logNotFoundDependency } from './errors';\r\nimport { Token } from './types';\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__injector__') as any;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n\r\ntype InjectorContextType = { injector?: Injector };\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext<InjectorContextType>({});\r\nif (__DEV__) {\r\n\tInjectorContext.displayName = 'InjectorContext';\r\n}\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport abstract class Injector<P = {}> extends Component<P> {\r\n\t_parent?: Injector;\r\n\r\n\t_bindingMap!: Map<Token, Function>;\r\n\r\n\t_instanceMap!: Map<Token, Object>;\r\n\r\n\t_childNotifications = new LiteEventImpl();\r\n\r\n\tabstract _initInstance(instance: Object): void;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target: Object) {\r\n\tlet injector = (target as InjectedInstance)[INJECTOR];\r\n\tif (injector) {\r\n\t\treturn injector;\r\n\t}\r\n\tinjector = currentInjector || ((target as Component).context as InjectorContextType)?.injector;\r\n\tif (injector instanceof Injector) {\r\n\t\t(target as InjectedInstance)[INJECTOR] = injector;\r\n\t\treturn injector;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nlet currentInjector: Injector | null = null;\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector: Injector | undefined, token: Token) {\r\n\tif (registrationQueue.length > 0) {\r\n\t\tregistrationQueue.forEach(registration => {\r\n\t\t\tregistration();\r\n\t\t});\r\n\t\tregistrationQueue.length = 0;\r\n\t}\r\n\twhile (injector) {\r\n\t\tlet instance = injector._instanceMap.get(token)!;\r\n\t\tif (instance !== undefined) {\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tconst binding = injector._bindingMap.get(token);\r\n\t\tif (binding) {\r\n\t\t\tconst prevInjector = currentInjector;\r\n\t\t\tcurrentInjector = injector;\r\n\t\t\ttry {\r\n\t\t\t\tinstance = binding(injector);\r\n\t\t\t} finally {\r\n\t\t\t\tcurrentInjector = prevInjector;\r\n\t\t\t}\r\n\t\t\tinjector._instanceMap.set(token, instance);\r\n\t\t\tinjector._initInstance(instance);\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tinjector = injector._parent;\r\n\t}\r\n\tif (__DEV__) {\r\n\t\tlogNotFoundDependency(token);\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const registrationQueue: (() => void)[] = [];\r\n","import 'reflect-metadata';\r\nimport { InjectorContext, getInjector, getInstance } from './injector';\r\nimport { isValidMetadata, isReactComponent, isFunction, Constructor, Token } from './types';\r\nimport { getDebugName, logInvalidMetadata, logNotFoundProvider, logError } from './errors';\r\nimport { ComponentClass } from 'react';\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param token Dependency injection token\r\n * @returns Property decorator\r\n */\r\nexport function inject(token?: Token): PropertyDecorator;\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n */\r\nexport function inject(target: Object, key: string | symbol): void;\r\n/**\r\n * Create a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param target The object in which we inject class instance\r\n * @param token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function inject<T>(target: Object, token: Constructor<T> | Token): T;\r\n\r\nexport function inject<T>(targetOrToken?: Object | Token, keyOrToken?: string | symbol | Token | Constructor<T>) {\r\n\tif (isFunction(keyOrToken)) {\r\n\t\treturn injectFunction(targetOrToken as Object, keyOrToken);\r\n\t}\r\n\r\n\tlet token = targetOrToken as Object;\r\n\tif (!keyOrToken) {\r\n\t\treturn injectDecorator;\r\n\t}\r\n\treturn injectDecorator(token, keyOrToken as string | symbol);\r\n\r\n\tfunction injectDecorator(prototype: Object, key: string | symbol) {\r\n\t\tif (__DEV__) {\r\n\t\t\tdefineContextType(prototype);\r\n\t\t} else {\r\n\t\t\t(prototype.constructor as ComponentClass).contextType = InjectorContext;\r\n\t\t}\r\n\r\n\t\tif (!token) {\r\n\t\t\ttoken = Reflect.getMetadata('design:type', prototype, key);\r\n\t\t\tif (__DEV__) {\r\n\t\t\t\tif (!isValidMetadata(token)) {\r\n\t\t\t\t\tlogInvalidMetadata(targetOrToken as Object, token);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst descriptor = {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tget() {\r\n\t\t\t\tconst instance = injectFunction(this, token);\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t\treturn instance;\r\n\t\t\t},\r\n\t\t\tset(instance: Object) {\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(prototype, key, descriptor);\r\n\r\n\t\treturn descriptor;\r\n\t}\r\n}\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Object} target The object in which we inject class instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nfunction injectFunction(target: Object, token: Token) {\r\n\tconst injector = getInjector(target);\r\n\tif (__DEV__) {\r\n\t\tif (!injector) {\r\n\t\t\tlogNotFoundProvider(target);\r\n\t\t}\r\n\t}\r\n\treturn getInstance(injector, token);\r\n}\r\n\r\n/**\r\n * Set Class.contextType = InjectorContext\r\n * @internal\r\n * @param {Object} prototype React Component prototype\r\n */\r\nfunction defineContextType(prototype: Object) {\r\n\tif (isReactComponent(prototype)) {\r\n\t\tconst constructor = prototype.constructor;\r\n\t\tconst className = getDebugName(constructor);\r\n\t\tif ((constructor as ComponentClass).contextType !== InjectorContext) {\r\n\t\t\tif ((constructor as ComponentClass).contextType) {\r\n\t\t\t\tlogError(`Decorator tries to overwrite existing ${className}.contextType`);\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(constructor, 'contextType', {\r\n\t\t\t\t\tget() {\r\n\t\t\t\t\t\treturn InjectorContext;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset() {\r\n\t\t\t\t\t\tlogError(`You are trying to overwrite ${className}.contextType = InjectorContext`);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","import { INJECTOR, getInstance, Injector } from './injector';\r\nimport { isFunction, isToken, Token, Constructor, Definition, DefinitionObject } from './types';\r\nimport { logIncorrectBinding, logError, getDebugName } from './errors';\r\n\r\nconst IS_BINDING: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__binding__') as any;\r\ninterface BindingMark {\r\n\t[IS_BINDING]?: boolean;\r\n}\r\ntype BindingFunction = ((injector: Injector) => any) & BindingMark;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n/**\r\n * Bind type to specified class.\r\n * @param constructor Service constructor\r\n * @returns Dependency resolver\r\n */\r\nexport function toClass<T>(constructor: Constructor<T>) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(constructor)) {\r\n\t\t\tlogError(`Class ${getDebugName(constructor)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => {\r\n\t\tconst instance = new constructor() as InjectedInstance;\r\n\t\tif (!instance[INJECTOR]) {\r\n\t\t\tinstance[INJECTOR] = injector;\r\n\t\t}\r\n\t\treturn instance;\r\n\t});\r\n}\r\n\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T>(factory: () => T): Function;\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param deps Factory dependencies\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T extends [any, ...any[]]>(deps: { [K in keyof T]: Constructor<T[K]> | Token }, factory: (...args: T) => any): Function;\r\nexport function toFactory(depsOrFactory?: any, factory?: any) {\r\n\tif (__DEV__) {\r\n\t\tif (factory) {\r\n\t\t\tif (!Array.isArray(depsOrFactory)) {\r\n\t\t\t\tlogError(`Dependency array ${getDebugName(depsOrFactory)} is invalid`);\r\n\t\t\t}\r\n\t\t\tif (!isFunction(factory)) {\r\n\t\t\t\tlogError(`Factory ${getDebugName(factory)} is not a valid dependency`);\r\n\t\t\t}\r\n\t\t} else if (!isFunction(depsOrFactory)) {\r\n\t\t\tlogError(`Factory ${getDebugName(depsOrFactory)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(factory ? injector => factory(...depsOrFactory.map((token: Token) => getInstance(injector, token))) : depsOrFactory);\r\n}\r\n\r\n/**\r\n * Bind type to specified value.\r\n * @param  value\r\n * @returns Dependency resolver\r\n */\r\nexport function toValue(value: any) {\r\n\tif (__DEV__) {\r\n\t\tif (value === undefined) {\r\n\t\t\tlogError(`Please specify some value`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(() => value);\r\n}\r\n\r\n/**\r\n * Bind type to existing instance located by token.\r\n * @param {Token} token\r\n * @return Dependency resolver\r\n */\r\nexport function toExisting(token: Token) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(token)) {\r\n\t\t\tlogError(`Token ${getDebugName(token)} is not a valid dependency injection token`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * Mark function as binding function.\r\n * @internal\r\n * @param {Function} binding\r\n * @returns {Function}\r\n */\r\nfunction asBinding(binding: BindingFunction): Function {\r\n\tbinding[IS_BINDING] = true;\r\n\treturn binding;\r\n}\r\n\r\n/**\r\n * Add bindings to bindings Map\r\n * @internal\r\n */\r\nexport function addBindings(bindingMap: Map<Token, Function>, definitions: Definition[]) {\r\n\tdefinitions.forEach(definition => {\r\n\t\tlet token, binding;\r\n\t\tif (typeof definition == 'object' && (definition as DefinitionObject).token && (definition as DefinitionObject).binding) {\r\n\t\t\ttoken = (definition as DefinitionObject).token;\r\n\t\t\tbinding = (definition as DefinitionObject).binding;\r\n\t\t}\r\n\t\tif (Array.isArray(definition)) {\r\n\t\t\t[token, binding = token] = definition;\r\n\t\t} else {\r\n\t\t\ttoken = binding = definition;\r\n\t\t}\r\n\t\tif (__DEV__) {\r\n\t\t\tif (!isToken(token) || !isFunction(binding)) {\r\n\t\t\t\tlogIncorrectBinding(token, binding as Object);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// @ts-ignore\r\n\t\tbindingMap.set(token, binding[IS_BINDING] ? binding : toClass(binding));\r\n\t});\r\n}\r\n","import { createElement, ComponentType, ComponentClass, ReactNode } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { Injector, InjectorContext, registrationQueue } from './injector';\r\nimport { addBindings } from './bindings';\r\nimport { isObject, isFunction, Definition, Token } from './types';\r\nimport { logError, getDebugName } from './errors';\r\n\r\ntype Provider = {\r\n\t/**\r\n\t * Register dependency injection bindings in scope of decorated class\r\n\t * @param definitions Dependency injection configuration\r\n\t * @returns Decorated constructor\r\n\t */\r\n\tregister(...definitions: Definition[]): void;\r\n};\r\n\r\ntype ProviderMixin<T> = T &\r\n\tProvider & {\r\n\t\tcontextType: typeof InjectorContext;\r\n\t\tWrappedComponent: T;\r\n\t};\r\n\r\nconst Initialized: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__init__') as any;\r\nexport abstract class InjectedService {\r\n\t[Initialized]?: boolean;\r\n\tabstract initProvider(refresh: () => void): void;\r\n}\r\n/**\r\n * Decorator or HOC that register dependency injection bindings\r\n * in scope of decorated class\r\n * @param definitions Dependency injection configuration\r\n * @returns Decorator or HOC\r\n */\r\nexport const provider: (...definitions: Definition[]) => <P = {}>(target: ComponentType<P>) => ProviderMixin<ComponentType<P>> = (...definitions) => Wrapped => {\r\n\tconst bindingMap = new Map<Token, Function>();\r\n\r\n\taddBindings(bindingMap, definitions);\r\n\r\n\tclass Provider extends Injector {\r\n\t\t_parent = (this.context as any)?.injector as Injector;\r\n\t\t_bindingMap = bindingMap;\r\n\t\t_instanceMap = new Map();\r\n\t\tstate = { injector: this };\r\n\r\n\t\t_initInstance(instance: Object) {\r\n\t\t\tif (instance instanceof InjectedService && !instance[Initialized]) {\r\n\t\t\t\tinstance.initProvider(() => {\r\n\t\t\t\t\tthis.setState({ injector: this });\r\n\t\t\t\t\tthis._childNotifications.trigger();\r\n\t\t\t\t});\r\n\t\t\t\tinstance[Initialized] = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcomponentDidMount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tthis._initInstance(instance);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tcomponentWillUnmount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tif (isObject(instance) && isFunction(instance.dispose)) {\r\n\t\t\t\t\tinstance.dispose();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trender(): ReactNode {\r\n\t\t\treturn createElement(InjectorContext.Provider, { value: this.state }, createElement(Wrapped, this.props as any));\r\n\t\t}\r\n\r\n\t\tstatic WrappedComponent = Wrapped;\r\n\r\n\t\t/**\r\n\t\t * Register dependency injection bindings in scope of decorated class\r\n\t\t * @param {...Definition} definitions Dependency injection configuration\r\n\t\t */\r\n\t\tstatic register(...definitions: Definition[]) {\r\n\t\t\taddBindings(bindingMap, definitions);\r\n\t\t}\r\n\t}\r\n\r\n\tif (__DEV__) {\r\n\t\t(Provider as ComponentClass).displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n\t\tObject.defineProperty(Provider, 'contextType', {\r\n\t\t\tget() {\r\n\t\t\t\treturn InjectorContext;\r\n\t\t\t},\r\n\t\t\tset() {\r\n\t\t\t\tlogError(`You are trying to overwrite ${(Provider as ComponentClass).displayName}.contextType = InjectorContext`);\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\tProvider.contextType = InjectorContext;\r\n\t}\r\n\r\n\t// static fields from component should be visible on the generated Consumer\r\n\treturn hoistNonReactStatics(Provider as unknown as ComponentType<any>, Wrapped) as any;\r\n};\r\n\r\n/**\r\n * Decorator that lazily registers class in scope of specified Provider.\r\n * @param getProvider Lambda function that returns Provider\r\n * @param biding Dependency injection binding\r\n * @returns Decorator\r\n */\r\n\r\nexport const registerIn: <T extends Function>(getProvider: () => Provider, binding?: Function) => (target: T) => T = (getProvider, binding) => constructor => {\r\n\tregistrationQueue.push(() => {\r\n\t\tif (__DEV__) {\r\n\t\t\tconst provider = getProvider();\r\n\t\t\tif (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n\t\t\t\tlogError(`${getDebugName(provider)} is not a valid Provider. Please use:\\n` + `@registerIn(() => MyProvider)\\n` + `class ${getDebugName(constructor)} {}\\n`);\r\n\t\t\t} else {\r\n\t\t\t\tprovider.register(binding ? [constructor, binding] : constructor);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tgetProvider().register(binding ? [constructor, binding] : constructor);\r\n\t\t}\r\n\t});\r\n\treturn constructor;\r\n};\r\n","import { useContext, useEffect, useRef, useState } from 'react';\r\nimport { InjectorContext, getInstance, Injector } from './injector';\r\nimport { logNotFoundProvider } from './errors';\r\nimport { Token } from './types';\r\n\r\n/**\r\n * React hook for resolving a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param  token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function useInstance(token: Token) {\r\n\tconst ref = useRef<Object | undefined>(undefined);\r\n\tconst injector = useContext(InjectorContext)?.injector;\r\n\tif (__DEV__) {\r\n\t\tif (!injector) {\r\n\t\t\tlogNotFoundProvider();\r\n\t\t}\r\n\t}\r\n\tconst result = ref.current || (ref.current = getInstance(injector, token));\r\n\r\n\tconst [, updater] = useState({});\r\n\tconst refUpd = useRef({ updater });\r\n\tuseEffect(() => {\r\n\t\t// if token found in nearest provider - no update is required - useContext already invoke rerender,\r\n\t\t// otherwise we should manually refresh component\r\n\t\tlet event: () => void;\r\n\t\tlet publisher: Injector;\r\n\t\tif (injector && result) {\r\n\t\t\tif (!injector._instanceMap.has(token)) {\r\n\t\t\t\tlet i = injector._parent;\r\n\t\t\t\twhile (i) {\r\n\t\t\t\t\tif (i._instanceMap.has(token)) {\r\n\t\t\t\t\t\tpublisher = i;\r\n\t\t\t\t\t\tevent = i._childNotifications.on(() => refUpd.current.updater({}));\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti = i._parent;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn () => {\r\n\t\t\trefUpd.current.updater = () => {};\r\n\t\t\tif (publisher) {\r\n\t\t\t\tpublisher._childNotifications.off(event);\r\n\t\t\t}\r\n\t\t};\r\n\t}, []);\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * React hook for resolving a class instances that registered by some Provider in hierarchy.\r\n * Instances are cached in Provider that registers it's classes.\r\n * @param  tokens Dependency injection tokens\r\n * @returns Resolved class instances\r\n */\r\nexport function useInstances(...tokens: Token[]) {\r\n\tconst ref = useRef<(Object | undefined)[] | null>(null);\r\n\tconst injector = useContext(InjectorContext)?.injector;\r\n\tif (__DEV__) {\r\n\t\tif (!injector) {\r\n\t\t\tlogNotFoundProvider();\r\n\t\t}\r\n\t}\r\n\r\n\tconst result = ref.current || (ref.current = tokens.map(token => getInstance(injector, token)));\r\n\r\n\tconst [, updater] = useState({});\r\n\tconst refUpd = useRef({ updater });\r\n\tuseEffect(() => {\r\n\t\t// if token found in nearest provider - no update is required - useContext already invoke rerender,\r\n\t\t// otherwise we should manually refresh component\r\n\t\tconst subscriptions: { event: () => void; publisher: Injector }[] = [];\r\n\r\n\t\tif (injector) {\r\n\t\t\ttokens.forEach(token => {\r\n\t\t\t\tif (!injector._instanceMap.has(token)) {\r\n\t\t\t\t\tlet i = injector._parent;\r\n\t\t\t\t\twhile (i) {\r\n\t\t\t\t\t\tif (i._instanceMap.has(token)) {\r\n\t\t\t\t\t\t\tsubscriptions.push({\r\n\t\t\t\t\t\t\t\tpublisher: i,\r\n\t\t\t\t\t\t\t\tevent: i._childNotifications.on(() => refUpd.current.updater({}))\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti = i._parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn () => {\r\n\t\t\trefUpd.current.updater = () => {};\r\n\t\t\tsubscriptions.forEach(s => s.publisher._childNotifications.off(s.event));\r\n\t\t};\r\n\t}, []);\r\n\treturn result;\r\n}\r\n","import { createElement, FC, /* useCallback, DependencyList, */ useRef, Fragment, PropsWithChildren } from 'react';\r\nimport { Definition } from './ioc/types';\r\nimport { provider } from './ioc';\r\n\r\nconst ComponentWithService: FC<PropsWithChildren> = ({ children }) => createElement(Fragment, null, children);\r\n\r\nexport const ComponentWithServices: FC<PropsWithChildren<{\r\n\tservices: Definition[];\r\n}>> = ({ services, children }) => {\r\n\tconst ref = useRef(provider(...services)(ComponentWithService));\r\n\treturn createElement(ref.current, null, children);\r\n};\r\n"],"names":["LiteEventImpl","this","handlers","prototype","on","handler","push","off","filter","h","trigger","data","slice","forEach","isFunction","arg","isObject","INJECTOR","Symbol","InjectorContext","createContext","Injector","_super","_this","apply","arguments","_childNotifications","__extends","Component","getInjector","target","injector","currentInjector","_a","context","getInstance","token","registrationQueue","length","registration","instance","_instanceMap","get","undefined","binding","_bindingMap","prevInjector","set","_initInstance","_parent","inject","targetOrToken","keyOrToken","injectFunction","injectDecorator","key","constructor","contextType","Reflect","getMetadata","descriptor","configurable","enumerable","Object","defineProperty","writable","value","IS_BINDING","toClass","asBinding","toFactory","depsOrFactory","factory","map","toValue","toExisting","addBindings","bindingMap","definitions","definition","Array","isArray","Initialized","InjectedService","provider","_i","Wrapped","Map","Provider","state","initProvider","setState","componentDidMount","componentWillUnmount","dispose","render","createElement","props","register","WrappedComponent","hoistNonReactStatics","registerIn","getProvider","useInstance","ref","useRef","useContext","result","current","updater","useState","refUpd","useEffect","event","publisher","has","i","useInstances","tokens","subscriptions","s","ComponentWithService","children","Fragment","ComponentWithServices","services"],"mappings":"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"}