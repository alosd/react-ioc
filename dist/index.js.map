{"version":3,"file":"index.js","sources":["../src/ioc/types.ts","../src/ioc/errors.ts","../src/ioc/injector.ts","../src/ioc/inject.ts","../src/ioc/bindings.ts","../src/ioc/provider.ts","../src/ioc/hooks.ts","../src/services/service.ts","../src/services/decorators.ts"],"sourcesContent":["export type Token = Function | Object | string | symbol;\r\nexport type Definition = Function | [Function] | [Token, Function];\r\n\r\nexport type Constructor<T> = new (...args: any[]) => T;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isFunction(arg: any): arg is Function {\r\n\treturn typeof arg === 'function';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isObject(arg: any): arg is Object {\r\n\treturn arg && typeof arg === 'object';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isString(arg: any): arg is string {\r\n\treturn typeof arg === 'string';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isSymbol(arg: any): arg is symbol {\r\n\treturn typeof arg === 'symbol';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isToken(arg: any): arg is Token {\r\n\treturn isFunction(arg) || isObject(arg) || isString(arg) || isSymbol(arg);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isReactComponent(prototype: any) {\r\n\treturn isObject(prototype) && isObject(prototype.isReactComponent);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isValidMetadata(arg: any): arg is Function {\r\n\treturn isFunction(arg) && [Object, Function, Number, String, Boolean].indexOf(arg) === -1;\r\n}\r\n","import { isFunction, isObject, isReactComponent, Token } from './types';\r\nimport { FunctionComponent, Component } from 'react';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getDebugName(value: FunctionComponent | Component | Object) {\r\n\tif (isFunction(value)) {\r\n\t\treturn String(value.displayName || value.name);\r\n\t}\r\n\tif (isObject(value) && isFunction(value.constructor)) {\r\n\t\treturn String(value.constructor.name);\r\n\t}\r\n\treturn String(value);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logError(message?: string) {\r\n\ttry {\r\n\t\tthrow new Error(message);\r\n\t} catch (e) {\r\n\t\tconsole.error(e);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logIncorrectBinding(token: Token, binding: Function | Object) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst bindingName = getDebugName(binding);\r\n\tlogError(`Binding [${tokenName}, ${bindingName}] is incorrect.`);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundDependency(token: Token) {\r\n\tconst name = getDebugName(token);\r\n\tlogError(\r\n\t\t`Dependency ${name} is not found.\r\nPlease register ${name} in some Provider e.g.\r\n@provider([${name}, ${name}])\r\nclass App extends React.Component { /*...*/ }`\r\n\t);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundProvider(target?: Object) {\r\n\tif (isReactComponent(target)) {\r\n\t\tconst name = getDebugName(target!);\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider and set ${name}.contextType = InjectorContext e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }\r\n  class ${name} extends React.Component {\r\n    static contextType = InjectorContext;\r\n  }`\r\n\t\t);\r\n\t} else {\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }`\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logInvalidMetadata(target: Object, token: Token) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst targetName = getDebugName(target);\r\n\tlogError(\r\n\t\t`${tokenName} is not a valid dependency.\r\nPlease specify ES6 class as property type e.g.\r\nclass MyService {}\r\nclass ${targetName} {\r\n  @inject myService: MyService;\r\n}`\r\n\t);\r\n}\r\n","import { Component, createContext } from 'react';\r\nimport { logNotFoundDependency } from './errors';\r\nimport { Token } from './types';\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__injector__') as any;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext<{ injector?: Injector }>({});\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport abstract class Injector<P = {}> extends Component<P> {\r\n\t_parent!: Injector;\r\n\r\n\t_bindingMap!: Map<Token, Function>;\r\n\r\n\t_instanceMap!: Map<Token, Object>;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target: Object) {\r\n\tlet injector = (target as InjectedInstance)[INJECTOR];\r\n\tif (injector) {\r\n\t\treturn injector;\r\n\t}\r\n\tinjector = currentInjector || (target as Component).context;\r\n\tif (injector instanceof Injector) {\r\n\t\t(target as InjectedInstance)[INJECTOR] = injector;\r\n\t\treturn injector;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nlet currentInjector: Injector | null = null;\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector: Injector | undefined, token: Token) {\r\n\tif (registrationQueue.length > 0) {\r\n\t\tregistrationQueue.forEach(registration => {\r\n\t\t\tregistration();\r\n\t\t});\r\n\t\tregistrationQueue.length = 0;\r\n\t}\r\n\twhile (injector) {\r\n\t\tlet instance = injector._instanceMap.get(token)!;\r\n\t\tif (instance !== undefined) {\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tconst binding = injector._bindingMap.get(token);\r\n\t\tif (binding) {\r\n\t\t\tconst prevInjector = currentInjector;\r\n\t\t\tcurrentInjector = injector;\r\n\t\t\ttry {\r\n\t\t\t\tinstance = binding(injector);\r\n\t\t\t} finally {\r\n\t\t\t\tcurrentInjector = prevInjector;\r\n\t\t\t}\r\n\t\t\tinjector._instanceMap.set(token, instance);\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tinjector = injector._parent;\r\n\t}\r\n\tif (__DEV__) {\r\n\t\tlogNotFoundDependency(token);\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const registrationQueue: (() => void)[] = [];\r\n","import 'reflect-metadata';\r\nimport { InjectorContext, getInjector, getInstance } from './injector';\r\nimport { isValidMetadata, isReactComponent, isFunction, Constructor, Token } from './types';\r\nimport { getDebugName, logInvalidMetadata, logNotFoundProvider, logError } from './errors';\r\nimport { ComponentClass } from 'react';\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param token Dependency injection token\r\n * @returns Property decorator\r\n */\r\nexport function inject(token?: Token): PropertyDecorator;\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n */\r\nexport function inject(target: Object, key: string | symbol): void;\r\n/**\r\n * Create a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param target The object in which we inject class instance\r\n * @param token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function inject<T>(target: Object, token: Constructor<T> | Token): T;\r\n\r\nexport function inject<T>(targetOrToken?: Object | Token, keyOrToken?: string | symbol | Token | Constructor<T>) {\r\n\tif (isFunction(keyOrToken)) {\r\n\t\treturn injectFunction(targetOrToken as Object, keyOrToken);\r\n\t}\r\n\r\n\tlet token = targetOrToken as Object;\r\n\tif (!keyOrToken) {\r\n\t\treturn injectDecorator;\r\n\t}\r\n\treturn injectDecorator(token, keyOrToken as string | symbol);\r\n\r\n\tfunction injectDecorator(prototype: Object, key: string | symbol) {\r\n\t\tif (__DEV__) {\r\n\t\t\tdefineContextType(prototype);\r\n\t\t} else {\r\n\t\t\t(prototype.constructor as ComponentClass).contextType = InjectorContext;\r\n\t\t}\r\n\r\n\t\tif (!token) {\r\n\t\t\ttoken = Reflect.getMetadata('design:type', prototype, key);\r\n\t\t\tif (__DEV__) {\r\n\t\t\t\tif (!isValidMetadata(token)) {\r\n\t\t\t\t\tlogInvalidMetadata(targetOrToken as Object, token);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst descriptor = {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tget() {\r\n\t\t\t\tconst instance = injectFunction(this, token);\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t\treturn instance;\r\n\t\t\t},\r\n\t\t\tset(instance: Object) {\r\n\t\t\t\tObject.defineProperty(this, key, {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tvalue: instance\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(prototype, key, descriptor);\r\n\r\n\t\treturn descriptor;\r\n\t}\r\n}\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Object} target The object in which we inject class instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nfunction injectFunction(target: Object, token: Token) {\r\n\tconst injector = getInjector(target);\r\n\tif (__DEV__) {\r\n\t\tif (!injector) {\r\n\t\t\tlogNotFoundProvider(target);\r\n\t\t}\r\n\t}\r\n\treturn getInstance(injector, token);\r\n}\r\n\r\n/**\r\n * Set Class.contextType = InjectorContext\r\n * @internal\r\n * @param {Object} prototype React Component prototype\r\n */\r\nfunction defineContextType(prototype: Object) {\r\n\tif (isReactComponent(prototype)) {\r\n\t\tconst constructor = prototype.constructor;\r\n\t\tconst className = getDebugName(constructor);\r\n\t\tif ((constructor as ComponentClass).contextType !== InjectorContext) {\r\n\t\t\tif ((constructor as ComponentClass).contextType) {\r\n\t\t\t\tlogError(`Decorator tries to overwrite existing ${className}.contextType`);\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(constructor, 'contextType', {\r\n\t\t\t\t\tget() {\r\n\t\t\t\t\t\treturn InjectorContext;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset() {\r\n\t\t\t\t\t\tlogError(`You are trying to overwrite ${className}.contextType = InjectorContext`);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","import { INJECTOR, getInstance, Injector } from './injector';\r\nimport { isFunction, isToken, Token, Constructor, Definition } from './types';\r\nimport { logIncorrectBinding, logError, getDebugName } from './errors';\r\n\r\nconst IS_BINDING: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__binding__') as any;\r\ninterface BindingMark {\r\n\t[IS_BINDING]?: boolean;\r\n}\r\ntype BindingFunction = ((injector: Injector) => any) & BindingMark;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n/**\r\n * Bind type to specified class.\r\n * @param constructor Service constructor\r\n * @returns Dependency resolver\r\n */\r\nexport function toClass<T>(constructor: Constructor<T>) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(constructor)) {\r\n\t\t\tlogError(`Class ${getDebugName(constructor)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => {\r\n\t\tconst instance = new constructor() as InjectedInstance;\r\n\t\tif (!instance[INJECTOR]) {\r\n\t\t\tinstance[INJECTOR] = injector;\r\n\t\t}\r\n\t\treturn instance;\r\n\t});\r\n}\r\n\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T>(factory: () => T): Function;\r\n/**\r\n * Bind dependency to specified factory funciton.\r\n * @param deps Factory dependencies\r\n * @param factory Factory\r\n * @returns Dependency resolver\r\n */\r\nexport function toFactory<T extends [any, ...any[]]>(deps: { [K in keyof T]: Constructor<T[K]> | Token }, factory: (...args: T) => any): Function;\r\nexport function toFactory(depsOrFactory?: any, factory?: any) {\r\n\tif (__DEV__) {\r\n\t\tif (factory) {\r\n\t\t\tif (!Array.isArray(depsOrFactory)) {\r\n\t\t\t\tlogError(`Dependency array ${getDebugName(depsOrFactory)} is invalid`);\r\n\t\t\t}\r\n\t\t\tif (!isFunction(factory)) {\r\n\t\t\t\tlogError(`Factory ${getDebugName(factory)} is not a valid dependency`);\r\n\t\t\t}\r\n\t\t} else if (!isFunction(depsOrFactory)) {\r\n\t\t\tlogError(`Factory ${getDebugName(depsOrFactory)} is not a valid dependency`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(factory ? injector => factory(...depsOrFactory.map((token: Token) => getInstance(injector, token))) : depsOrFactory);\r\n}\r\n\r\n/**\r\n * Bind type to specified value.\r\n * @param  value\r\n * @returns Dependency resolver\r\n */\r\nexport function toValue(value: any) {\r\n\tif (__DEV__) {\r\n\t\tif (value === undefined) {\r\n\t\t\tlogError(`Please specify some value`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(() => value);\r\n}\r\n\r\n/**\r\n * Bind type to existing instance located by token.\r\n * @param {Token} token\r\n * @return Dependency resolver\r\n */\r\nexport function toExisting(token: Token) {\r\n\tif (__DEV__) {\r\n\t\tif (!isFunction(token)) {\r\n\t\t\tlogError(`Token ${getDebugName(token)} is not a valid dependency injection token`);\r\n\t\t}\r\n\t}\r\n\treturn asBinding(injector => getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * Mark function as binding function.\r\n * @internal\r\n * @param {Function} binding\r\n * @returns {Function}\r\n */\r\nfunction asBinding(binding: BindingFunction): Function {\r\n\tbinding[IS_BINDING] = true;\r\n\treturn binding;\r\n}\r\n\r\n/**\r\n * Add bindings to bindings Map\r\n * @internal\r\n */\r\nexport function addBindings(bindingMap: Map<Token, Function>, definitions: Definition[]) {\r\n\tdefinitions.forEach(definition => {\r\n\t\tlet token, binding;\r\n\t\tif (Array.isArray(definition)) {\r\n\t\t\t[token, binding = token] = definition;\r\n\t\t} else {\r\n\t\t\ttoken = binding = definition;\r\n\t\t}\r\n\t\tif (__DEV__) {\r\n\t\t\tif (!isToken(token) || !isFunction(binding)) {\r\n\t\t\t\tlogIncorrectBinding(token, binding as Object);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// @ts-ignore\r\n\t\tbindingMap.set(token, binding[IS_BINDING] ? binding : toClass(binding));\r\n\t});\r\n}\r\n","import { createElement, ComponentType, ComponentClass } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { Injector, InjectorContext, registrationQueue } from './injector';\r\nimport { addBindings } from './bindings';\r\nimport { isObject, isFunction, Definition, Token } from './types';\r\nimport { logError, getDebugName } from './errors';\r\n\r\ntype Provider = {\r\n\t/**\r\n\t * Register dependency injection bindings in scope of decorated class\r\n\t * @param definitions Dependency injection configuration\r\n\t * @returns Decorated constructor\r\n\t */\r\n\tregister(...definitions: Definition[]): void;\r\n};\r\n\r\ntype ProviderMixin<T> = T &\r\n\tProvider & {\r\n\t\tcontextType: typeof InjectorContext;\r\n\t\tWrappedComponent: T;\r\n\t};\r\n\r\nexport abstract class InjectedService {\r\n\tabstract initProvider(refresh: () => void): void;\r\n}\r\n/**\r\n * Decorator or HOC that register dependency injection bindings\r\n * in scope of decorated class\r\n * @param definitions Dependency injection configuration\r\n * @returns Decorator or HOC\r\n */\r\nexport const provider: (...definitions: Definition[]) => <P = {}>(target: ComponentType<P>) => ProviderMixin<ComponentType<P>> = (...definitions) => Wrapped => {\r\n\tconst bindingMap = new Map<Token, Function>();\r\n\r\n\taddBindings(bindingMap, definitions);\r\n\r\n\tclass Provider extends Injector {\r\n\t\t_parent = this.context;\r\n\t\t_bindingMap = bindingMap;\r\n\t\t_instanceMap = new Map();\r\n\r\n\t\tcomponentDidMount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tif (instance instanceof InjectedService) {\r\n\t\t\t\t\tinstance.initProvider(() => this.setState({ injector: this }));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tcomponentWillUnmount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tif (isObject(instance) && isFunction(instance.dispose)) {\r\n\t\t\t\t\tinstance.dispose();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trender() {\r\n\t\t\treturn createElement(InjectorContext.Provider, { value: { injector: this } }, createElement(Wrapped, this.props as any));\r\n\t\t}\r\n\r\n\t\tstatic WrappedComponent = Wrapped;\r\n\r\n\t\t/**\r\n\t\t * Register dependency injection bindings in scope of decorated class\r\n\t\t * @param {...Definition} definitions Dependency injection configuration\r\n\t\t */\r\n\t\tstatic register(...definitions: Definition[]) {\r\n\t\t\taddBindings(bindingMap, definitions);\r\n\t\t}\r\n\t}\r\n\r\n\tif (__DEV__) {\r\n\t\t(Provider as ComponentClass).displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n\t\tObject.defineProperty(Provider, 'contextType', {\r\n\t\t\tget() {\r\n\t\t\t\treturn InjectorContext;\r\n\t\t\t},\r\n\t\t\tset() {\r\n\t\t\t\tlogError(`You are trying to overwrite ${(Provider as ComponentClass).displayName}.contextType = InjectorContext`);\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\tProvider.contextType = InjectorContext;\r\n\t}\r\n\r\n\t// static fields from component should be visible on the generated Consumer\r\n\treturn hoistNonReactStatics(Provider, Wrapped) as any;\r\n};\r\n\r\n/**\r\n * Decorator that lazily registers class in scope of specified Provider.\r\n * @param getProvider Lambda function that returns Provider\r\n * @param biding Dependency injection binding\r\n * @returns Decorator\r\n */\r\n\r\nexport const registerIn: <T extends Function>(getProvider: () => Provider, binding?: Function) => (target: T) => T = (getProvider, binding) => constructor => {\r\n\tregistrationQueue.push(() => {\r\n\t\tif (__DEV__) {\r\n\t\t\tconst provider = getProvider();\r\n\t\t\tif (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n\t\t\t\tlogError(`${getDebugName(provider)} is not a valid Provider. Please use:\\n` + `@registerIn(() => MyProvider)\\n` + `class ${getDebugName(constructor)} {}\\n`);\r\n\t\t\t} else {\r\n\t\t\t\tprovider.register(binding ? [constructor, binding] : constructor);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tgetProvider().register(binding ? [constructor, binding] : constructor);\r\n\t\t}\r\n\t});\r\n\treturn constructor;\r\n};\r\n","import { useContext, useRef } from \"react\";\r\nimport { InjectorContext, getInstance } from \"./injector\";\r\nimport { logNotFoundProvider } from \"./errors\";\r\nimport type { Token } from './types';\r\n\r\n/**\r\n * React hook for resolving a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param  token Dependency injection token\r\n * @returns Resolved class instance\r\n */\r\nexport function useInstance(token:Token) {\r\n  const ref = useRef<Object|undefined>(undefined);\r\n  const injector = useContext(InjectorContext)?.injector;\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return ref.current || (ref.current = getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * React hook for resolving a class instances that registered by some Provider in hierarchy.\r\n * Instances are cached in Provider that registers it's classes.\r\n * @param  tokens Dependency injection tokens\r\n * @returns Resolved class instances\r\n */\r\nexport function useInstances(...tokens:Token[]) {\r\n  const ref = useRef<(Object|undefined)[] |  null>(null);\r\n  const injector = useContext(InjectorContext)?.injector;\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return (\r\n    ref.current ||\r\n    (ref.current = tokens.map(token => getInstance(injector, token)))\r\n  );\r\n}\r\n","import { Draft, createDraft, finishDraft, immerable } from 'immer';\r\nimport { logError } from '../ioc/errors';\r\nimport { InjectedService } from '../ioc/provider';\r\n\r\nexport const PROVIDER: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__store__') as any;\r\nexport const STORES: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__stores__') as any;\r\nexport const REFRESH: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__refresh__') as any;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ImmutableServiceInternal {\r\n\t[REFRESH]?: () => void;\r\n\t[PROVIDER]: MutationProvider;\r\n\t[STORES]: string[];\r\n\t[index: string]: any;\r\n\tRefreshContext(): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n\r\nclass MutationProvider {\r\n\tprivate count = 0;\r\n\tprivate draft?: Draft<ImmutableServiceInternal>;\r\n\tprivate service: ImmutableServiceInternal;\r\n\tconstructor(service: ImmutableService) {\r\n\t\tthis.service = (service as unknown) as ImmutableServiceInternal;\r\n\t}\r\n\tstart(inc = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconst draft = (this.draft = this.draft ?? createDraft(this.service));\r\n\r\n\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\tthis.service[x] = draft[x];\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (inc) this.count++;\r\n\t}\r\n\tfinish(refresh: boolean = true, dec = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconsole.warn('the finish method must be called after corresponding start method');\r\n\t\t} else {\r\n\t\t\tif (dec) this.count--;\r\n\t\t\tif (this.count == 0) {\r\n\t\t\t\tconst draft = this.draft;\r\n\t\t\t\tif (draft) {\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tdraft[x] = this.service[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tconst newstate = finishDraft(draft);\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tthis.service[x] = newstate[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.draft = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (__DEV__) {\r\n\t\t\t\t\t\tlogError('previous state is absent');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (refresh) {\r\n\t\t\tthis.service.RefreshContext();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// @ts-ignore\r\nexport abstract class ImmutableService extends InjectedService {\r\n\tprivate [REFRESH]: () => void;\r\n\t// @ts-ignore\r\n\tprivate [STORES]: string[];\r\n\t// @ts-ignore\r\n\tprivate [PROVIDER]: MutationProvider;\r\n\t// @ts-ignore\r\n\tprivate [immerable]: boolean;\r\n\r\n\t// @ts-ignore\r\n\tprivate initProvider(refresh: () => void) {\r\n\t\tthis[REFRESH] = refresh;\r\n\t\tthis[PROVIDER].start();\r\n\t\tthis[PROVIDER].finish();\r\n\t}\r\n\r\n\tprotected RefreshContext() {\r\n\t\tif (this[REFRESH]) {\r\n\t\t\tthis[REFRESH]();\r\n\t\t}\r\n\t}\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis[STORES] = this[STORES] ?? [];\r\n\t\tthis[immerable] = true;\r\n\t\tthis[PROVIDER] = new MutationProvider(this);\r\n\t}\r\n\r\n\tprotected async waitForAsync<T>(promise: Promise<T>) {\r\n\t\tthis[PROVIDER].finish(true, false);\r\n\t\ttry {\r\n\t\t\treturn await promise;\r\n\t\t} finally {\r\n\t\t\tthis[PROVIDER].start(false);\r\n\t\t}\r\n\t}\r\n}\r\n","import { ImmutableServiceInternal, ImmutableService, STORES, PROVIDER } from './service';\r\n\r\n/**\r\n * Property Decorator convert property to immutable\r\n * Changes for such property allowed only from methods marked with @action or @asyncAction decorator\r\n */\r\nexport function store() {\r\n\treturn function(target: ImmutableService, propertyKey: string) {\r\n\t\tconst service = (target as unknown) as ImmutableServiceInternal;\r\n\t\tservice[STORES] = service[STORES] ?? [];\r\n\t\tservice[STORES].push(propertyKey);\r\n\t};\r\n}\r\n\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\n// export function asyncAction() {\r\n// \treturn function(target: ImmutableService, propertyKey: string, descriptor: PropertyDescriptor) {\r\n// \t\tconst fn = descriptor.value as Function;\r\n// \t\tdescriptor.value = async function(args: any[]) {\r\n// \t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n// \t\t\tlet res = undefined;\r\n// \t\t\ttry {\r\n// \t\t\t\tres = await fn.call(this, args);\r\n// \t\t\t} finally {\r\n// \t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n// \t\t\t}\r\n\r\n// \t\t\treturn res;\r\n// \t\t};\r\n// \t};\r\n// }\r\n\r\nconst waitForFinish = async (service: ImmutableServiceInternal, promise: Promise<any>) => {\r\n\ttry {\r\n\t\treturn await promise;\r\n\t} finally {\r\n\t\tservice[PROVIDER].finish();\r\n\t}\r\n};\r\nconst checkForPromise = (value: any) => {\r\n\t//return value instanceof Promise\r\n\treturn value && typeof value['then'] === 'function';\r\n};\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\nexport function action() {\r\n\treturn function(_target: ImmutableService, _propertyKey: string, descriptor: PropertyDescriptor) {\r\n\t\tconst fn = descriptor.value as Function;\r\n\t\tdescriptor.value = function(args: any[]) {\r\n\t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n\r\n\t\t\tlet isPromise = false;\r\n\t\t\ttry {\r\n\t\t\t\tlet res = fn.call(this, args);\r\n\t\t\t\tisPromise = checkForPromise(res);\r\n\t\t\t\tif (isPromise) {\r\n\t\t\t\t\treturn waitForFinish(this as ImmutableServiceInternal, res);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn res;\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (!isPromise) {\r\n\t\t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n}\r\n"],"names":["createContext","__extends","Component","createElement","useRef","useContext","createDraft","finishDraft","immerable"],"mappings":"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"}