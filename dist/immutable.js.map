{"version":3,"file":"immutable.js","sources":["../src/ioc/errors.ts","../src/liteEvent.ts","../src/ioc/injector.ts","../src/ioc/provider.ts","../src/services/service.ts","../src/services/decorators.ts"],"sourcesContent":["import { isFunction, isObject, isReactComponent, Token } from './types';\r\nimport { FunctionComponent, Component } from 'react';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getDebugName(value: FunctionComponent | Component | Object) {\r\n\tif (isFunction(value)) {\r\n\t\treturn String(value.displayName || value.name);\r\n\t}\r\n\tif (isObject(value) && isFunction(value.constructor)) {\r\n\t\treturn String(value.constructor.name);\r\n\t}\r\n\treturn String(value);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logError(message?: string) {\r\n\ttry {\r\n\t\tthrow new Error(message);\r\n\t} catch (e) {\r\n\t\tconsole.error(e);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logIncorrectBinding(token: Token, binding: Function | Object) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst bindingName = getDebugName(binding);\r\n\tlogError(`Binding [${tokenName}, ${bindingName}] is incorrect.`);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundDependency(token: Token) {\r\n\tconst name = getDebugName(token);\r\n\tlogError(\r\n\t\t`Dependency ${name} is not found.\r\nPlease register ${name} in some Provider e.g.\r\n@provider([${name}, ${name}])\r\nclass App extends React.Component { /*...*/ }`\r\n\t);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundProvider(target?: Object) {\r\n\tif (isReactComponent(target)) {\r\n\t\tconst name = getDebugName(target!);\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider and set ${name}.contextType = InjectorContext e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }\r\n  class ${name} extends React.Component {\r\n    static contextType = InjectorContext;\r\n  }`\r\n\t\t);\r\n\t} else {\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }`\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logInvalidMetadata(target: Object, token: Token) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst targetName = getDebugName(target);\r\n\tlogError(\r\n\t\t`${tokenName} is not a valid dependency.\r\nPlease specify ES6 class as property type e.g.\r\nclass MyService {}\r\nclass ${targetName} {\r\n  @inject myService: MyService;\r\n}`\r\n\t);\r\n}\r\n","/* Lite Event exports */\r\ntype ActionsType<T> = (data?: T) => void;\r\n\r\nexport interface LiteEvent<T = void> {\r\n\ton(handler: ActionsType<T>): ActionsType<T>;\r\n\toff(handler: ActionsType<T>): void;\r\n}\r\n\r\nexport class LiteEventImpl<T = void> implements LiteEvent<T> {\r\n\tprivate handlers: ActionsType<T>[] = [];\r\n\r\n\t// on(handler: () => void): () => void;\r\n\r\n\ton(handler: ActionsType<T>) {\r\n\t\tthis.handlers.push(handler);\r\n\t\treturn handler;\r\n\t}\r\n\r\n\toff(handler: ActionsType<T>) {\r\n\t\tthis.handlers = this.handlers.filter(h => h !== handler);\r\n\t}\r\n\r\n\ttrigger(data: T) {\r\n\t\tthis.handlers.slice(0).forEach(h => h(data!));\r\n\t}\r\n}\r\n","import { Component, createContext } from 'react';\r\nimport { LiteEventImpl } from '../liteEvent';\r\nimport { logNotFoundDependency } from './errors';\r\nimport { Token } from './types';\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__injector__') as any;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n\r\ntype InjectorContextType = { injector?: Injector };\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext<InjectorContextType>({});\r\nif (__DEV__) {\r\n\tInjectorContext.displayName = 'InjectorContext';\r\n}\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport abstract class Injector<P = {}> extends Component<P> {\r\n\t_parent?: Injector;\r\n\r\n\t_bindingMap!: Map<Token, Function>;\r\n\r\n\t_instanceMap!: Map<Token, Object>;\r\n\r\n\t_childNotifications = new LiteEventImpl();\r\n\r\n\tabstract _initInstance(instance: Object): void;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target: Object) {\r\n\tlet injector = (target as InjectedInstance)[INJECTOR];\r\n\tif (injector) {\r\n\t\treturn injector;\r\n\t}\r\n\tinjector = currentInjector || ((target as Component).context as InjectorContextType)?.injector;\r\n\tif (injector instanceof Injector) {\r\n\t\t(target as InjectedInstance)[INJECTOR] = injector;\r\n\t\treturn injector;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nlet currentInjector: Injector | null = null;\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector: Injector | undefined, token: Token) {\r\n\tif (registrationQueue.length > 0) {\r\n\t\tregistrationQueue.forEach(registration => {\r\n\t\t\tregistration();\r\n\t\t});\r\n\t\tregistrationQueue.length = 0;\r\n\t}\r\n\twhile (injector) {\r\n\t\tlet instance = injector._instanceMap.get(token)!;\r\n\t\tif (instance !== undefined) {\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tconst binding = injector._bindingMap.get(token);\r\n\t\tif (binding) {\r\n\t\t\tconst prevInjector = currentInjector;\r\n\t\t\tcurrentInjector = injector;\r\n\t\t\ttry {\r\n\t\t\t\tinstance = binding(injector);\r\n\t\t\t} finally {\r\n\t\t\t\tcurrentInjector = prevInjector;\r\n\t\t\t}\r\n\t\t\tinjector._instanceMap.set(token, instance);\r\n\t\t\tinjector._initInstance(instance);\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tinjector = injector._parent;\r\n\t}\r\n\tif (__DEV__) {\r\n\t\tlogNotFoundDependency(token);\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const registrationQueue: (() => void)[] = [];\r\n","import { createElement, ComponentType, ComponentClass, ReactNode } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { Injector, InjectorContext, registrationQueue } from './injector';\r\nimport { addBindings } from './bindings';\r\nimport { isObject, isFunction, Definition, Token } from './types';\r\nimport { logError, getDebugName } from './errors';\r\n\r\ntype Provider = {\r\n\t/**\r\n\t * Register dependency injection bindings in scope of decorated class\r\n\t * @param definitions Dependency injection configuration\r\n\t * @returns Decorated constructor\r\n\t */\r\n\tregister(...definitions: Definition[]): void;\r\n};\r\n\r\ntype ProviderMixin<T> = T &\r\n\tProvider & {\r\n\t\tcontextType: typeof InjectorContext;\r\n\t\tWrappedComponent: T;\r\n\t};\r\n\r\nconst Initialized: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__init__') as any;\r\nexport abstract class InjectedService {\r\n\t[Initialized]?: boolean;\r\n\tabstract initProvider(refresh: () => void): void;\r\n}\r\n/**\r\n * Decorator or HOC that register dependency injection bindings\r\n * in scope of decorated class\r\n * @param definitions Dependency injection configuration\r\n * @returns Decorator or HOC\r\n */\r\nexport const provider: (...definitions: Definition[]) => <P = {}>(target: ComponentType<P>) => ProviderMixin<ComponentType<P>> = (...definitions) => Wrapped => {\r\n\tconst bindingMap = new Map<Token, Function>();\r\n\r\n\taddBindings(bindingMap, definitions);\r\n\r\n\tclass Provider extends Injector {\r\n\t\t_parent = (this.context as any)?.injector as Injector;\r\n\t\t_bindingMap = bindingMap;\r\n\t\t_instanceMap = new Map();\r\n\t\tstate = { injector: this };\r\n\r\n\t\t_initInstance(instance: Object) {\r\n\t\t\tif (instance instanceof InjectedService && !instance[Initialized]) {\r\n\t\t\t\tinstance.initProvider(() => {\r\n\t\t\t\t\tthis.setState({ injector: this });\r\n\t\t\t\t\tthis._childNotifications.trigger();\r\n\t\t\t\t});\r\n\t\t\t\tinstance[Initialized] = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcomponentDidMount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tthis._initInstance(instance);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tcomponentWillUnmount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tif (isObject(instance) && isFunction(instance.dispose)) {\r\n\t\t\t\t\tinstance.dispose();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trender(): ReactNode {\r\n\t\t\treturn createElement(InjectorContext.Provider, { value: this.state }, createElement(Wrapped, this.props as any));\r\n\t\t}\r\n\r\n\t\tstatic WrappedComponent = Wrapped;\r\n\r\n\t\t/**\r\n\t\t * Register dependency injection bindings in scope of decorated class\r\n\t\t * @param {...Definition} definitions Dependency injection configuration\r\n\t\t */\r\n\t\tstatic register(...definitions: Definition[]) {\r\n\t\t\taddBindings(bindingMap, definitions);\r\n\t\t}\r\n\t}\r\n\r\n\tif (__DEV__) {\r\n\t\t(Provider as ComponentClass).displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n\t\tObject.defineProperty(Provider, 'contextType', {\r\n\t\t\tget() {\r\n\t\t\t\treturn InjectorContext;\r\n\t\t\t},\r\n\t\t\tset() {\r\n\t\t\t\tlogError(`You are trying to overwrite ${(Provider as ComponentClass).displayName}.contextType = InjectorContext`);\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\tProvider.contextType = InjectorContext;\r\n\t}\r\n\r\n\t// static fields from component should be visible on the generated Consumer\r\n\treturn hoistNonReactStatics(Provider as unknown as ComponentType<any>, Wrapped) as any;\r\n};\r\n\r\n/**\r\n * Decorator that lazily registers class in scope of specified Provider.\r\n * @param getProvider Lambda function that returns Provider\r\n * @param biding Dependency injection binding\r\n * @returns Decorator\r\n */\r\n\r\nexport const registerIn: <T extends Function>(getProvider: () => Provider, binding?: Function) => (target: T) => T = (getProvider, binding) => constructor => {\r\n\tregistrationQueue.push(() => {\r\n\t\tif (__DEV__) {\r\n\t\t\tconst provider = getProvider();\r\n\t\t\tif (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n\t\t\t\tlogError(`${getDebugName(provider)} is not a valid Provider. Please use:\\n` + `@registerIn(() => MyProvider)\\n` + `class ${getDebugName(constructor)} {}\\n`);\r\n\t\t\t} else {\r\n\t\t\t\tprovider.register(binding ? [constructor, binding] : constructor);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tgetProvider().register(binding ? [constructor, binding] : constructor);\r\n\t\t}\r\n\t});\r\n\treturn constructor;\r\n};\r\n","import { Draft, createDraft, finishDraft, immerable } from 'immer';\r\nimport { logError } from '../ioc/errors';\r\nimport { InjectedService } from '../ioc/provider';\r\n\r\nexport const PROVIDER: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__store__') as any;\r\nexport const STORES: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__stores__') as any;\r\nexport const REFRESH: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__refresh__') as any;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ImmutableServiceInternal {\r\n\t[REFRESH]?: () => void;\r\n\t[PROVIDER]: MutationProvider;\r\n\t[STORES]: string[];\r\n\t[index: string]: any;\r\n\tRefreshContext(): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n\r\nclass MutationProvider {\r\n\tprivate count = 0;\r\n\tprivate draft?: Draft<ImmutableServiceInternal>;\r\n\tprivate service: ImmutableServiceInternal;\r\n\tconstructor(service: ImmutableService) {\r\n\t\tthis.service = (service as unknown) as ImmutableServiceInternal;\r\n\t}\r\n\tstart(inc = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconst draft = (this.draft = this.draft ?? createDraft(this.service));\r\n\r\n\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\tthis.service[x] = draft[x];\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (inc) this.count++;\r\n\t}\r\n\tfinish(refresh: boolean = true, dec = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconsole.warn('the finish method must be called after corresponding start method');\r\n\t\t} else {\r\n\t\t\tif (dec) this.count--;\r\n\t\t\tif (this.count == 0) {\r\n\t\t\t\tconst draft = this.draft;\r\n\t\t\t\tif (draft) {\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tdraft[x] = this.service[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tconst newstate = finishDraft(draft);\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tthis.service[x] = newstate[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.draft = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (__DEV__) {\r\n\t\t\t\t\t\tlogError('previous state is absent');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (refresh) {\r\n\t\t\tthis.service.RefreshContext();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// @ts-ignore\r\nexport abstract class ImmutableService extends InjectedService {\r\n\tprivate [REFRESH]: (() => void) | undefined;\r\n\t// @ts-ignore\r\n\tprivate [STORES]: string[];\r\n\t// @ts-ignore\r\n\tprivate [PROVIDER]: MutationProvider;\r\n\t// @ts-ignore\r\n\tprivate [immerable]: boolean;\r\n\r\n\t// @ts-ignore\r\n\tprivate initProvider(refresh: () => void) {\r\n\t\tthis[REFRESH] = refresh;\r\n\t\tthis[PROVIDER].start();\r\n\t\tthis[PROVIDER].finish();\r\n\t}\r\n\r\n\tprotected RefreshContext() {\r\n\t\tif (this[REFRESH]) {\r\n\t\t\tthis[REFRESH]();\r\n\t\t}\r\n\t}\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\t// @ts-ignore\r\n\t\tthis[STORES] = this[STORES] ?? [];\r\n\t\tthis[immerable] = true;\r\n\t\tthis[PROVIDER] = new MutationProvider(this);\r\n\t}\r\n\r\n\tprotected async waitForAsync<T>(promise: Promise<T>) {\r\n\t\tthis[PROVIDER].finish(true, false);\r\n\t\ttry {\r\n\t\t\treturn await promise;\r\n\t\t} finally {\r\n\t\t\tthis[PROVIDER].start(false);\r\n\t\t}\r\n\t}\r\n}\r\n","import { ImmutableServiceInternal, ImmutableService, STORES, PROVIDER } from './service';\r\n\r\n/**\r\n * Property Decorator convert property to immutable\r\n * Changes for such property allowed only from methods marked with @action or @asyncAction decorator\r\n */\r\nexport function store() {\r\n\treturn function(target: ImmutableService, propertyKey: string) {\r\n\t\tconst service = (target as unknown) as ImmutableServiceInternal;\r\n\t\tservice[STORES] = service[STORES] ?? [];\r\n\t\tservice[STORES].push(propertyKey);\r\n\t};\r\n}\r\n\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\n// export function asyncAction() {\r\n// \treturn function(target: ImmutableService, propertyKey: string, descriptor: PropertyDescriptor) {\r\n// \t\tconst fn = descriptor.value as Function;\r\n// \t\tdescriptor.value = async function(args: any[]) {\r\n// \t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n// \t\t\tlet res = undefined;\r\n// \t\t\ttry {\r\n// \t\t\t\tres = await fn.call(this, args);\r\n// \t\t\t} finally {\r\n// \t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n// \t\t\t}\r\n\r\n// \t\t\treturn res;\r\n// \t\t};\r\n// \t};\r\n// }\r\n\r\nconst waitForFinish = async (service: ImmutableServiceInternal, promise: Promise<any>) => {\r\n\ttry {\r\n\t\treturn await promise;\r\n\t} finally {\r\n\t\tservice[PROVIDER].finish();\r\n\t}\r\n};\r\nconst checkForPromise = (value: any) => {\r\n\t//return value instanceof Promise\r\n\treturn value && typeof value['then'] === 'function';\r\n};\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\nexport function action() {\r\n\treturn function(_target: ImmutableService, _propertyKey: string, descriptor: PropertyDescriptor) {\r\n\t\tconst fn = descriptor.value as Function;\r\n\t\tdescriptor.value = function(args: any[]) {\r\n\t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n\r\n\t\t\tlet isPromise = false;\r\n\t\t\ttry {\r\n\t\t\t\tlet res = fn.call(this, args);\r\n\t\t\t\tisPromise = checkForPromise(res);\r\n\t\t\t\tif (isPromise) {\r\n\t\t\t\t\treturn waitForFinish(this as ImmutableServiceInternal, res);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn res;\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (!isPromise) {\r\n\t\t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n}\r\n"],"names":["createContext","__extends","Component","createDraft","finishDraft","immerable","__awaiter"],"mappings":"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"}