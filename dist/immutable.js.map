{"version":3,"file":"immutable.js","sources":["../src/ioc/types.ts","../src/ioc/errors.ts","../src/ioc/injector.ts","../src/ioc/provider.ts","../src/services/service.ts","../src/services/decorators.ts"],"sourcesContent":["export type Token = Function | Object | string | symbol;\r\nexport type DefinitionObject = { token: Token; binding: Function };\r\nexport type Definition = Function | [Function] | [Token, Function] | DefinitionObject;\r\n\r\nexport type Constructor<T> = new (...args: any[]) => T;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isFunction(arg: any): arg is Function {\r\n\treturn typeof arg === 'function';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isObject(arg: any): arg is Object {\r\n\treturn arg && typeof arg === 'object';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isString(arg: any): arg is string {\r\n\treturn typeof arg === 'string';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isSymbol(arg: any): arg is symbol {\r\n\treturn typeof arg === 'symbol';\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isToken(arg: any): arg is Token {\r\n\treturn isFunction(arg) || isObject(arg) || isString(arg) || isSymbol(arg);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isReactComponent(prototype: any) {\r\n\treturn isObject(prototype) && isObject(prototype.isReactComponent);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isValidMetadata(arg: any): arg is Function {\r\n\treturn isFunction(arg) && [Object, Function, Number, String, Boolean].indexOf(arg) === -1;\r\n}\r\n","import { isFunction, isObject, isReactComponent, Token } from './types';\r\nimport { FunctionComponent, Component } from 'react';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getDebugName(value: FunctionComponent | Component | Object) {\r\n\tif (isFunction(value)) {\r\n\t\treturn String(value.displayName || value.name);\r\n\t}\r\n\tif (isObject(value) && isFunction(value.constructor)) {\r\n\t\treturn String(value.constructor.name);\r\n\t}\r\n\treturn String(value);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logError(message?: string) {\r\n\ttry {\r\n\t\tthrow new Error(message);\r\n\t} catch (e) {\r\n\t\tconsole.error(e);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logIncorrectBinding(token: Token, binding: Function | Object) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst bindingName = getDebugName(binding);\r\n\tlogError(`Binding [${tokenName}, ${bindingName}] is incorrect.`);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundDependency(token: Token) {\r\n\tconst name = getDebugName(token);\r\n\tlogError(\r\n\t\t`Dependency ${name} is not found.\r\nPlease register ${name} in some Provider e.g.\r\n@provider([${name}, ${name}])\r\nclass App extends React.Component { /*...*/ }`\r\n\t);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logNotFoundProvider(target?: Object) {\r\n\tif (isReactComponent(target)) {\r\n\t\tconst name = getDebugName(target!);\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider and set ${name}.contextType = InjectorContext e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }\r\n  class ${name} extends React.Component {\r\n    static contextType = InjectorContext;\r\n  }`\r\n\t\t);\r\n\t} else {\r\n\t\tlogError(\r\n\t\t\t`Provider is not found.\r\n  Please define Provider e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }`\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function logInvalidMetadata(target: Object, token: Token) {\r\n\tconst tokenName = getDebugName(token);\r\n\tconst targetName = getDebugName(target);\r\n\tlogError(\r\n\t\t`${tokenName} is not a valid dependency.\r\nPlease specify ES6 class as property type e.g.\r\nclass MyService {}\r\nclass ${targetName} {\r\n  @inject myService: MyService;\r\n}`\r\n\t);\r\n}\r\n","import { Component, createContext } from 'react';\r\nimport { logNotFoundDependency } from './errors';\r\nimport { Token } from './types';\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__injector__') as any;\r\n\r\ninterface InjectedInstance {\r\n\t[INJECTOR]?: Injector;\r\n}\r\n\r\ntype InjectorContextType = { injector?: Injector };\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext<InjectorContextType>({});\r\nif (__DEV__) {\r\n\tInjectorContext.displayName = 'InjectorContext';\r\n}\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport abstract class Injector<P = {}> extends Component<P> {\r\n\t_parent?: Injector;\r\n\r\n\t_bindingMap!: Map<Token, Function>;\r\n\r\n\t_instanceMap!: Map<Token, Object>;\r\n\r\n\tabstract _initInstance(instance: Object): void;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target: Object) {\r\n\tlet injector = (target as InjectedInstance)[INJECTOR];\r\n\tif (injector) {\r\n\t\treturn injector;\r\n\t}\r\n\tinjector = currentInjector || ((target as Component).context as InjectorContextType)?.injector;\r\n\tif (injector instanceof Injector) {\r\n\t\t(target as InjectedInstance)[INJECTOR] = injector;\r\n\t\treturn injector;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nlet currentInjector: Injector | null = null;\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector: Injector | undefined, token: Token) {\r\n\tif (registrationQueue.length > 0) {\r\n\t\tregistrationQueue.forEach(registration => {\r\n\t\t\tregistration();\r\n\t\t});\r\n\t\tregistrationQueue.length = 0;\r\n\t}\r\n\twhile (injector) {\r\n\t\tlet instance = injector._instanceMap.get(token)!;\r\n\t\tif (instance !== undefined) {\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tconst binding = injector._bindingMap.get(token);\r\n\t\tif (binding) {\r\n\t\t\tconst prevInjector = currentInjector;\r\n\t\t\tcurrentInjector = injector;\r\n\t\t\ttry {\r\n\t\t\t\tinstance = binding(injector);\r\n\t\t\t} finally {\r\n\t\t\t\tcurrentInjector = prevInjector;\r\n\t\t\t}\r\n\t\t\tinjector._instanceMap.set(token, instance);\r\n\t\t\tinjector._initInstance(instance);\r\n\t\t\treturn instance;\r\n\t\t}\r\n\t\tinjector = injector._parent;\r\n\t}\r\n\tif (__DEV__) {\r\n\t\tlogNotFoundDependency(token);\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const registrationQueue: (() => void)[] = [];\r\n","import { createElement, ComponentType, ComponentClass } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { Injector, InjectorContext, registrationQueue } from './injector';\r\nimport { addBindings } from './bindings';\r\nimport { isObject, isFunction, Definition, Token } from './types';\r\nimport { logError, getDebugName } from './errors';\r\n\r\ntype Provider = {\r\n\t/**\r\n\t * Register dependency injection bindings in scope of decorated class\r\n\t * @param definitions Dependency injection configuration\r\n\t * @returns Decorated constructor\r\n\t */\r\n\tregister(...definitions: Definition[]): void;\r\n};\r\n\r\ntype ProviderMixin<T> = T &\r\n\tProvider & {\r\n\t\tcontextType: typeof InjectorContext;\r\n\t\tWrappedComponent: T;\r\n\t};\r\n\r\nconst Initialized: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__init__') as any;\r\nexport abstract class InjectedService {\r\n\t[Initialized]?: boolean;\r\n\tabstract initProvider(refresh: () => void): void;\r\n}\r\n/**\r\n * Decorator or HOC that register dependency injection bindings\r\n * in scope of decorated class\r\n * @param definitions Dependency injection configuration\r\n * @returns Decorator or HOC\r\n */\r\nexport const provider: (...definitions: Definition[]) => <P = {}>(target: ComponentType<P>) => ProviderMixin<ComponentType<P>> = (...definitions) => Wrapped => {\r\n\tconst bindingMap = new Map<Token, Function>();\r\n\r\n\taddBindings(bindingMap, definitions);\r\n\r\n\tclass Provider extends Injector {\r\n\t\t_parent = this.context?.injector;\r\n\t\t_bindingMap = bindingMap;\r\n\t\t_instanceMap = new Map();\r\n\t\t_initInstance(instance: Object) {\r\n\t\t\tif (instance instanceof InjectedService && !instance[Initialized]) {\r\n\t\t\t\tinstance.initProvider(() => this.setState({ injector: this }));\r\n\t\t\t\tinstance[Initialized] = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcomponentDidMount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tthis._initInstance(instance);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tcomponentWillUnmount() {\r\n\t\t\tthis._instanceMap.forEach(instance => {\r\n\t\t\t\tif (isObject(instance) && isFunction(instance.dispose)) {\r\n\t\t\t\t\tinstance.dispose();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trender() {\r\n\t\t\treturn createElement(InjectorContext.Provider, { value: { injector: this } }, createElement(Wrapped, this.props as any));\r\n\t\t}\r\n\r\n\t\tstatic WrappedComponent = Wrapped;\r\n\r\n\t\t/**\r\n\t\t * Register dependency injection bindings in scope of decorated class\r\n\t\t * @param {...Definition} definitions Dependency injection configuration\r\n\t\t */\r\n\t\tstatic register(...definitions: Definition[]) {\r\n\t\t\taddBindings(bindingMap, definitions);\r\n\t\t}\r\n\t}\r\n\r\n\tif (__DEV__) {\r\n\t\t(Provider as ComponentClass).displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n\t\tObject.defineProperty(Provider, 'contextType', {\r\n\t\t\tget() {\r\n\t\t\t\treturn InjectorContext;\r\n\t\t\t},\r\n\t\t\tset() {\r\n\t\t\t\tlogError(`You are trying to overwrite ${(Provider as ComponentClass).displayName}.contextType = InjectorContext`);\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\tProvider.contextType = InjectorContext;\r\n\t}\r\n\r\n\t// static fields from component should be visible on the generated Consumer\r\n\treturn hoistNonReactStatics(Provider, Wrapped) as any;\r\n};\r\n\r\n/**\r\n * Decorator that lazily registers class in scope of specified Provider.\r\n * @param getProvider Lambda function that returns Provider\r\n * @param biding Dependency injection binding\r\n * @returns Decorator\r\n */\r\n\r\nexport const registerIn: <T extends Function>(getProvider: () => Provider, binding?: Function) => (target: T) => T = (getProvider, binding) => constructor => {\r\n\tregistrationQueue.push(() => {\r\n\t\tif (__DEV__) {\r\n\t\t\tconst provider = getProvider();\r\n\t\t\tif (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n\t\t\t\tlogError(`${getDebugName(provider)} is not a valid Provider. Please use:\\n` + `@registerIn(() => MyProvider)\\n` + `class ${getDebugName(constructor)} {}\\n`);\r\n\t\t\t} else {\r\n\t\t\t\tprovider.register(binding ? [constructor, binding] : constructor);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tgetProvider().register(binding ? [constructor, binding] : constructor);\r\n\t\t}\r\n\t});\r\n\treturn constructor;\r\n};\r\n","import { Draft, createDraft, finishDraft, immerable } from 'immer';\r\nimport { logError } from '../ioc/errors';\r\nimport { InjectedService } from '../ioc/provider';\r\n\r\nexport const PROVIDER: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__store__') as any;\r\nexport const STORES: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__stores__') as any;\r\nexport const REFRESH: unique symbol = (typeof Symbol === 'function' ? Symbol() : '__refresh__') as any;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ImmutableServiceInternal {\r\n\t[REFRESH]?: () => void;\r\n\t[PROVIDER]: MutationProvider;\r\n\t[STORES]: string[];\r\n\t[index: string]: any;\r\n\tRefreshContext(): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n\r\nclass MutationProvider {\r\n\tprivate count = 0;\r\n\tprivate draft?: Draft<ImmutableServiceInternal>;\r\n\tprivate service: ImmutableServiceInternal;\r\n\tconstructor(service: ImmutableService) {\r\n\t\tthis.service = (service as unknown) as ImmutableServiceInternal;\r\n\t}\r\n\tstart(inc = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconst draft = (this.draft = this.draft ?? createDraft(this.service));\r\n\r\n\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\tthis.service[x] = draft[x];\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (inc) this.count++;\r\n\t}\r\n\tfinish(refresh: boolean = true, dec = true) {\r\n\t\tif (this.count == 0) {\r\n\t\t\tconsole.warn('the finish method must be called after corresponding start method');\r\n\t\t} else {\r\n\t\t\tif (dec) this.count--;\r\n\t\t\tif (this.count == 0) {\r\n\t\t\t\tconst draft = this.draft;\r\n\t\t\t\tif (draft) {\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tdraft[x] = this.service[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tconst newstate = finishDraft(draft);\r\n\t\t\t\t\tthis.service[STORES].forEach(x => {\r\n\t\t\t\t\t\tthis.service[x] = newstate[x];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.draft = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (__DEV__) {\r\n\t\t\t\t\t\tlogError('previous state is absent');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (refresh) {\r\n\t\t\tthis.service.RefreshContext();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// @ts-ignore\r\nexport abstract class ImmutableService extends InjectedService {\r\n\tprivate [REFRESH]: () => void;\r\n\t// @ts-ignore\r\n\tprivate [STORES]: string[];\r\n\t// @ts-ignore\r\n\tprivate [PROVIDER]: MutationProvider;\r\n\t// @ts-ignore\r\n\tprivate [immerable]: boolean;\r\n\r\n\t// @ts-ignore\r\n\tprivate initProvider(refresh: () => void) {\r\n\t\tthis[REFRESH] = refresh;\r\n\t\tthis[PROVIDER].start();\r\n\t\tthis[PROVIDER].finish();\r\n\t}\r\n\r\n\tprotected RefreshContext() {\r\n\t\tif (this[REFRESH]) {\r\n\t\t\tthis[REFRESH]();\r\n\t\t}\r\n\t}\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis[STORES] = this[STORES] ?? [];\r\n\t\tthis[immerable] = true;\r\n\t\tthis[PROVIDER] = new MutationProvider(this);\r\n\t}\r\n\r\n\tprotected async waitForAsync<T>(promise: Promise<T>) {\r\n\t\tthis[PROVIDER].finish(true, false);\r\n\t\ttry {\r\n\t\t\treturn await promise;\r\n\t\t} finally {\r\n\t\t\tthis[PROVIDER].start(false);\r\n\t\t}\r\n\t}\r\n}\r\n","import { ImmutableServiceInternal, ImmutableService, STORES, PROVIDER } from './service';\r\n\r\n/**\r\n * Property Decorator convert property to immutable\r\n * Changes for such property allowed only from methods marked with @action or @asyncAction decorator\r\n */\r\nexport function store() {\r\n\treturn function(target: ImmutableService, propertyKey: string) {\r\n\t\tconst service = (target as unknown) as ImmutableServiceInternal;\r\n\t\tservice[STORES] = service[STORES] ?? [];\r\n\t\tservice[STORES].push(propertyKey);\r\n\t};\r\n}\r\n\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\n// export function asyncAction() {\r\n// \treturn function(target: ImmutableService, propertyKey: string, descriptor: PropertyDescriptor) {\r\n// \t\tconst fn = descriptor.value as Function;\r\n// \t\tdescriptor.value = async function(args: any[]) {\r\n// \t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n// \t\t\tlet res = undefined;\r\n// \t\t\ttry {\r\n// \t\t\t\tres = await fn.call(this, args);\r\n// \t\t\t} finally {\r\n// \t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n// \t\t\t}\r\n\r\n// \t\t\treturn res;\r\n// \t\t};\r\n// \t};\r\n// }\r\n\r\nconst waitForFinish = async (service: ImmutableServiceInternal, promise: Promise<any>) => {\r\n\ttry {\r\n\t\treturn await promise;\r\n\t} finally {\r\n\t\tservice[PROVIDER].finish();\r\n\t}\r\n};\r\nconst checkForPromise = (value: any) => {\r\n\t//return value instanceof Promise\r\n\treturn value && typeof value['then'] === 'function';\r\n};\r\n/**\r\n * Method decorator allow to change properties marked with @store within method.\r\n * After method execution, the React Context in which the service is located will be updated\r\n */\r\nexport function action() {\r\n\treturn function(_target: ImmutableService, _propertyKey: string, descriptor: PropertyDescriptor) {\r\n\t\tconst fn = descriptor.value as Function;\r\n\t\tdescriptor.value = function(args: any[]) {\r\n\t\t\t(this as ImmutableServiceInternal)[PROVIDER].start();\r\n\r\n\t\t\tlet isPromise = false;\r\n\t\t\ttry {\r\n\t\t\t\tlet res = fn.call(this, args);\r\n\t\t\t\tisPromise = checkForPromise(res);\r\n\t\t\t\tif (isPromise) {\r\n\t\t\t\t\treturn waitForFinish(this as ImmutableServiceInternal, res);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn res;\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (!isPromise) {\r\n\t\t\t\t\t(this as ImmutableServiceInternal)[PROVIDER].finish();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n}\r\n"],"names":["createContext","__extends","Component","createDraft","finishDraft","immerable"],"mappings":"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"}